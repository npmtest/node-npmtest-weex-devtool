<!doctype html>
<html lang="en">
<head>
    <title>Code coverage report for node-npmtest-weex-devtool/node_modules/weex-devtool/frontend/inspector/es_tree_module.js</title>
    <meta charset="utf-8">
    <style>
        body, html {
            margin:0; padding: 0;
        }
        body {
            font-family: Arial, Helvetica;
            font-size: 10pt;
        }
        div.header, div.footer {
            background: #eee;
            padding: 1em;
        }
        div.header {
            height: 160px;
            padding: 0 1em 0 1em;
            z-index: 100;
            position: fixed;
            top: 0;
            border-bottom: 1px solid #666;
            width: 100%;
        }
        div.footer {
            border-top: 1px solid #666;
        }
        div.body {
            margin-top: 170px;
        }
        div.meta {
            font-size: 90%;
            text-align: center;
        }
        h1, h2, h3 {
            font-weight: normal;
        }
        h1 {
            font-size: 12pt;
        }
        h2 {
            font-size: 10pt;
        }
        pre {
            font-family: Menlo, Monaco, Consolas, Courier New, monospace;
            margin: 0;
            padding: 0;
            font-size: 14px;
            tab-size: 2;
        }

        div.path { font-size: 110%; }
        div.path a:link, div.path a:visited { color: #000; }
        table.coverage { border-collapse: collapse; margin:0; padding: 0 }

        table.coverage td {
            margin: 0;
            padding: 0;
            color: #111;
            vertical-align: top;
        }
        table.coverage td.line-count {
            width: 50px;
            text-align: right;
            padding-right: 5px;
        }
        table.coverage td.line-coverage {
            color: #777 !important;
            text-align: right;
            border-left: 1px solid #666;
            border-right: 1px solid #666;
        }

        table.coverage td.text {
        }

        table.coverage td span.cline-any {
            display: inline-block;
            padding: 0 5px;
            width: 40px;
        }
        table.coverage td span.cline-neutral {
            background: #eee;
        }
        table.coverage td span.cline-yes {
            background: #b5d592;
            color: #999;
        }
        table.coverage td span.cline-no {
            background: #fc8c84;
        }

        .cstat-yes { color: #111; }
        .cstat-no { background: #fc8c84; color: #111; }
        .fstat-no { background: #ffc520; color: #111 !important; }
        .cbranch-no { background:  yellow !important; color: #111; }

        .cstat-skip { background: #ddd; color: #111; }
        .fstat-skip { background: #ddd; color: #111 !important; }
        .cbranch-skip { background: #ddd !important; color: #111; }

        .missing-if-branch {
            display: inline-block;
            margin-right: 10px;
            position: relative;
            padding: 0 4px;
            background: black;
            color: yellow;
        }

        .skip-if-branch {
            display: none;
            margin-right: 10px;
            position: relative;
            padding: 0 4px;
            background: #ccc;
            color: white;
        }

        .missing-if-branch .typ, .skip-if-branch .typ {
            color: inherit !important;
        }

        .entity, .metric { font-weight: bold; }
        .metric { display: inline-block; border: 1px solid #333; padding: 0.3em; background: white; }
        .metric small { font-size: 80%; font-weight: normal; color: #666; }

        div.coverage-summary table { border-collapse: collapse; margin: 3em; font-size: 110%; }
        div.coverage-summary td, div.coverage-summary table  th { margin: 0; padding: 0.25em 1em; border-top: 1px solid #666; border-bottom: 1px solid #666; }
        div.coverage-summary th { text-align: left; border: 1px solid #666; background: #eee; font-weight: normal; }
        div.coverage-summary th.file { border-right: none !important; }
        div.coverage-summary th.pic { border-left: none !important; text-align: right; }
        div.coverage-summary th.pct { border-right: none !important; }
        div.coverage-summary th.abs { border-left: none !important; text-align: right; }
        div.coverage-summary td.pct { text-align: right; border-left: 1px solid #666; }
        div.coverage-summary td.abs { text-align: right; font-size: 90%; color: #444; border-right: 1px solid #666; }
        div.coverage-summary td.file { text-align: right; border-left: 1px solid #666; white-space: nowrap;  }
        div.coverage-summary td.pic { min-width: 120px !important;  }
        div.coverage-summary a:link { color: #000; }
        div.coverage-summary a:visited { color: #333; }
        div.coverage-summary tfoot td { border-top: 1px solid #666; }

        div.coverage-summary .yui3-datatable-sort-indicator, div.coverage-summary .dummy-sort-indicator {
            height: 10px;
            width: 7px;
            display: inline-block;
            margin-left: 0.5em;
        }
        div.coverage-summary .yui3-datatable-sort-indicator {
            background: no-repeat scroll 0 0 transparent;
        }
        div.coverage-summary .yui3-datatable-sorted .yui3-datatable-sort-indicator {
            background-position: 0 -20px;
        }
        div.coverage-summary .yui3-datatable-sorted-desc .yui3-datatable-sort-indicator {
            background-position: 0 -10px;
        }

        .high { background: #b5d592 !important; }
        .medium { background: #ffe87c !important; }
        .low { background: #fc8c84 !important; }

        span.cover-fill, span.cover-empty {
            display:inline-block;
            border:1px solid #444;
            background: white;
            height: 12px;
        }
        span.cover-fill {
            background: #ccc;
            border-right: 1px solid #444;
        }
        span.cover-empty {
            background: white;
            border-left: none;
        }
        span.cover-full {
            border-right: none !important;
        }
        pre.prettyprint {
            border: none !important;
            padding: 0 !important;
            margin: 0 !important;
        }
        .com { color: #999 !important; }
        .ignore-none { color: #999; font-weight: normal; }

    </style>
</head>
<body>
<div class="header low">
    <h1 style="font-weight: bold;">
        <a href="https://github.com/npmtest/node-npmtest-weex-devtool">npmtest-weex-devtool (v0.0.1)</a>
    </h1>
    <h1>Code coverage report for <span class="entity">node-npmtest-weex-devtool/node_modules/weex-devtool/frontend/inspector/es_tree_module.js</span></h1>
    <h2>
        
        Statements: <span class="metric">18.64% <small>(388 / 2082)</small></span> &nbsp;&nbsp;&nbsp;&nbsp;
        
        
        Branches: <span class="metric">1.75% <small>(23 / 1312)</small></span> &nbsp;&nbsp;&nbsp;&nbsp;
        
        
        Functions: <span class="metric">13.82% <small>(30 / 217)</small></span> &nbsp;&nbsp;&nbsp;&nbsp;
        
        
        Lines: <span class="metric">46.71% <small>(78 / 167)</small></span> &nbsp;&nbsp;&nbsp;&nbsp;
        
        Ignored: <span class="metric"><span class="ignore-none">none</span></span> &nbsp;&nbsp;&nbsp;&nbsp;
    </h2>
    <div class="path"><a href="../../../../../index.html">All files</a> &#187; <a href="index.html">node-npmtest-weex-devtool/node_modules/weex-devtool/frontend/inspector/</a> &#187; es_tree_module.js</div>
</div>
<div class="body">
<pre><table class="coverage">
<tr><td class="line-count">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168</td><td class="line-coverage"><span class="cline-any cline-yes">92</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-yes">14</span>
<span class="cline-any cline-yes">14</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-yes">148</span>
<span class="cline-any cline-yes">148</span>
<span class="cline-any cline-yes">74</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span></td><td class="text"><pre class="prettyprint lang-js">(function(f){<span class="missing-if-branch" title="else path not taken" >E</span>if(typeof exports==="object"&amp;&amp;typeof module!=="undefined"){module.exports=f()}else <span class="cstat-no" title="statement not covered" >if(typeof define==="function"&amp;&amp;define.amd){<span class="cstat-no" title="statement not covered" >define([],f)}</span>else{<span class="cstat-no" title="statement not covered" >var g;<span class="cstat-no" title="statement not covered" >i</span>f(typeof window!=="undefined"){<span class="cstat-no" title="statement not covered" >g=window}</span>else <span class="cstat-no" title="statement not covered" >if(typeof global!=="undefined"){<span class="cstat-no" title="statement not covered" >g=global}</span>else <span class="cstat-no" title="statement not covered" >if(typeof self!=="undefined"){<span class="cstat-no" title="statement not covered" >g=self}</span>else{<span class="cstat-no" title="statement not covered" >g=this}<span class="cstat-no" title="statement not covered" ></span>g</span></span></span>.acorn=f()}</span>}</span>)(function(){var define,module,exports;return(function e(t,n,r){function s(o,u){if(!n[o]){<span class="missing-if-branch" title="if path not taken" >I</span>if(!t[o]){<span class="cstat-no" title="statement not covered" >var a=typeof require=="function"&amp;&amp;require;<span class="cstat-no" title="statement not covered" >i</span>f(!u&amp;&amp;a)<span class="cstat-no" title="statement not covered" >return a(o,!0);<span class="cstat-no" title="statement not covered" >i</span></span>f(i)<span class="cstat-no" title="statement not covered" >return i(o,!0);<span class="cstat-no" title="statement not covered" >v</span></span>ar f=new Error("Cannot find module '"+o+"'");<span class="cstat-no" title="statement not covered" >t</span>hrow f.code="MODULE_NOT_FOUND",f}</span>var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:<span class="branch-1 cbranch-no" title="branch not covered" >e)</span>},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&amp;&amp;require;for(var o=0;o&lt;r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){"use strict";var _tokentype=_dereq_("./tokentype");var _state=_dereq_("./state");var pp=_state.Parser.prototype;pp.checkPropClash=<span class="fstat-no" title="function not covered" >function(prop,propHash){<span class="cstat-no" title="statement not covered" ></span>if(this.options.ecmaVersion&gt;=6&amp;&amp;(prop.computed||prop.method||prop.shorthand))<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >v</span></span>ar key=prop.key;<span class="cstat-no" title="statement not covered" >v</span>ar name=undefined;<span class="cstat-no" title="statement not covered" >s</span>witch(key.type){case"Identifier":<span class="cstat-no" title="statement not covered" >name=key.name;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"Literal":<span class="cstat-no" title="statement not covered" >name=String(key.value);<span class="cstat-no" title="statement not covered" >b</span>reak;d</span>efault:<span class="cstat-no" title="statement not covered" >return;}</span></span>
<span class="cstat-no" title="statement not covered" >var kind=prop.kind;<span class="cstat-no" title="statement not covered" >i</span>f(this.options.ecmaVersion&gt;=6){<span class="cstat-no" title="statement not covered" >if(name==="__proto__"&amp;&amp;kind==="init"){<span class="cstat-no" title="statement not covered" >if(propHash.proto)<span class="cstat-no" title="statement not covered" >this.raise(key.start,"Redefinition of __proto__ property");<span class="cstat-no" title="statement not covered" >p</span></span>ropHash.proto=true;}</span></span></span>
<span class="cstat-no" title="statement not covered" >return;}</span>
<span class="cstat-no" title="statement not covered" >name="$"+name;<span class="cstat-no" title="statement not covered" >v</span>ar other=propHash[name];<span class="cstat-no" title="statement not covered" >i</span>f(other){<span class="cstat-no" title="statement not covered" >var isGetSet=kind!=="init";<span class="cstat-no" title="statement not covered" >i</span>f((this.strict||isGetSet)&amp;&amp;other[kind]||!(isGetSet^other.init))<span class="cstat-no" title="statement not covered" >this.raise(key.start,"Redefinition of property");}</span></span>else{<span class="cstat-no" title="statement not covered" >other=propHash[name]={init:false,get:false,set:false};}</span></span>
<span class="cstat-no" title="statement not covered" >other[kind]=true;}</span>;pp.parseExpression=<span class="fstat-no" title="function not covered" >function(noIn,refShorthandDefaultPos){<span class="cstat-no" title="statement not covered" ></span>var startPos=this.start,startLoc=this.startLoc;<span class="cstat-no" title="statement not covered" >v</span>ar expr=this.parseMaybeAssign(noIn,refShorthandDefaultPos);<span class="cstat-no" title="statement not covered" >i</span>f(this.type===_tokentype.types.comma){<span class="cstat-no" title="statement not covered" >var node=this.startNodeAt(startPos,startLoc);<span class="cstat-no" title="statement not covered" >n</span>ode.expressions=[expr];<span class="cstat-no" title="statement not covered" >w</span>hile(this.eat(_tokentype.types.comma))<span class="cstat-no" title="statement not covered" >node.expressions.push(this.parseMaybeAssign(noIn,refShorthandDefaultPos));<span class="cstat-no" title="statement not covered" >r</span></span>eturn this.finishNode(node,"SequenceExpression");}</span></span>
<span class="cstat-no" title="statement not covered" >return expr;}</span>;pp.parseMaybeAssign=<span class="fstat-no" title="function not covered" >function(noIn,refShorthandDefaultPos,afterLeftParse){<span class="cstat-no" title="statement not covered" ></span>if(this.type==_tokentype.types._yield&amp;&amp;this.inGenerator)<span class="cstat-no" title="statement not covered" >return this.parseYield();<span class="cstat-no" title="statement not covered" >v</span></span>ar failOnShorthandAssign=undefined;<span class="cstat-no" title="statement not covered" >i</span>f(!refShorthandDefaultPos){<span class="cstat-no" title="statement not covered" >refShorthandDefaultPos={start:0};<span class="cstat-no" title="statement not covered" >f</span>ailOnShorthandAssign=true;}</span>else{<span class="cstat-no" title="statement not covered" >failOnShorthandAssign=false;}</span></span>
<span class="cstat-no" title="statement not covered" >var startPos=this.start,startLoc=this.startLoc;<span class="cstat-no" title="statement not covered" >i</span>f(this.type==_tokentype.types.parenL||this.type==_tokentype.types.name)<span class="cstat-no" title="statement not covered" >this.potentialArrowAt=this.start;<span class="cstat-no" title="statement not covered" >v</span></span>ar left=this.parseMaybeConditional(noIn,refShorthandDefaultPos);<span class="cstat-no" title="statement not covered" >i</span>f(afterLeftParse)<span class="cstat-no" title="statement not covered" >left=afterLeftParse.call(this,left,startPos,startLoc);<span class="cstat-no" title="statement not covered" >i</span></span>f(this.type.isAssign){<span class="cstat-no" title="statement not covered" >var node=this.startNodeAt(startPos,startLoc);<span class="cstat-no" title="statement not covered" >n</span>ode.operator=this.value;<span class="cstat-no" title="statement not covered" >n</span>ode.left=this.type===_tokentype.types.eq?this.toAssignable(left):left;<span class="cstat-no" title="statement not covered" >r</span>efShorthandDefaultPos.start=0;<span class="cstat-no" title="statement not covered" >t</span>his.checkLVal(left);<span class="cstat-no" title="statement not covered" >t</span>his.next();<span class="cstat-no" title="statement not covered" >n</span>ode.right=this.parseMaybeAssign(noIn);<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishNode(node,"AssignmentExpression");}</span>else <span class="cstat-no" title="statement not covered" >if(failOnShorthandAssign&amp;&amp;refShorthandDefaultPos.start){<span class="cstat-no" title="statement not covered" >this.unexpected(refShorthandDefaultPos.start);}</span></span></span>
<span class="cstat-no" title="statement not covered" >return left;}</span>;pp.parseMaybeConditional=<span class="fstat-no" title="function not covered" >function(noIn,refShorthandDefaultPos){<span class="cstat-no" title="statement not covered" ></span>var startPos=this.start,startLoc=this.startLoc;<span class="cstat-no" title="statement not covered" >v</span>ar expr=this.parseExprOps(noIn,refShorthandDefaultPos);<span class="cstat-no" title="statement not covered" >i</span>f(refShorthandDefaultPos&amp;&amp;refShorthandDefaultPos.start)<span class="cstat-no" title="statement not covered" >return expr;<span class="cstat-no" title="statement not covered" >i</span></span>f(this.eat(_tokentype.types.question)){<span class="cstat-no" title="statement not covered" >var node=this.startNodeAt(startPos,startLoc);<span class="cstat-no" title="statement not covered" >n</span>ode.test=expr;<span class="cstat-no" title="statement not covered" >n</span>ode.consequent=this.parseMaybeAssign();<span class="cstat-no" title="statement not covered" >t</span>his.expect(_tokentype.types.colon);<span class="cstat-no" title="statement not covered" >n</span>ode.alternate=this.parseMaybeAssign(noIn);<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishNode(node,"ConditionalExpression");}</span></span>
<span class="cstat-no" title="statement not covered" >return expr;}</span>;pp.parseExprOps=<span class="fstat-no" title="function not covered" >function(noIn,refShorthandDefaultPos){<span class="cstat-no" title="statement not covered" ></span>var startPos=this.start,startLoc=this.startLoc;<span class="cstat-no" title="statement not covered" >v</span>ar expr=this.parseMaybeUnary(refShorthandDefaultPos);<span class="cstat-no" title="statement not covered" >i</span>f(refShorthandDefaultPos&amp;&amp;refShorthandDefaultPos.start)<span class="cstat-no" title="statement not covered" >return expr;<span class="cstat-no" title="statement not covered" >r</span></span>eturn this.parseExprOp(expr,startPos,startLoc,-1,noIn);}</span>;pp.parseExprOp=<span class="fstat-no" title="function not covered" >function(left,leftStartPos,leftStartLoc,minPrec,noIn){<span class="cstat-no" title="statement not covered" ></span>var prec=this.type.binop;<span class="cstat-no" title="statement not covered" >i</span>f(prec!=null&amp;&amp;(!noIn||this.type!==_tokentype.types._in)){<span class="cstat-no" title="statement not covered" >if(prec&gt;minPrec){<span class="cstat-no" title="statement not covered" >var node=this.startNodeAt(leftStartPos,leftStartLoc);<span class="cstat-no" title="statement not covered" >n</span>ode.left=left;<span class="cstat-no" title="statement not covered" >n</span>ode.operator=this.value;<span class="cstat-no" title="statement not covered" >v</span>ar op=this.type;<span class="cstat-no" title="statement not covered" >t</span>his.next();<span class="cstat-no" title="statement not covered" >v</span>ar startPos=this.start,startLoc=this.startLoc;<span class="cstat-no" title="statement not covered" >n</span>ode.right=this.parseExprOp(this.parseMaybeUnary(),startPos,startLoc,prec,noIn);<span class="cstat-no" title="statement not covered" >t</span>his.finishNode(node,op===_tokentype.types.logicalOR||op===_tokentype.types.logicalAND?"LogicalExpression":"BinaryExpression");<span class="cstat-no" title="statement not covered" >r</span>eturn this.parseExprOp(node,leftStartPos,leftStartLoc,minPrec,noIn);}</span>}</span></span>
<span class="cstat-no" title="statement not covered" >return left;}</span>;pp.parseMaybeUnary=<span class="fstat-no" title="function not covered" >function(refShorthandDefaultPos){<span class="cstat-no" title="statement not covered" ></span>if(this.type.prefix){<span class="cstat-no" title="statement not covered" >var node=this.startNode(),update=this.type===_tokentype.types.incDec;<span class="cstat-no" title="statement not covered" >n</span>ode.operator=this.value;<span class="cstat-no" title="statement not covered" >n</span>ode.prefix=true;<span class="cstat-no" title="statement not covered" >t</span>his.next();<span class="cstat-no" title="statement not covered" >n</span>ode.argument=this.parseMaybeUnary();<span class="cstat-no" title="statement not covered" >i</span>f(refShorthandDefaultPos&amp;&amp;refShorthandDefaultPos.start)<span class="cstat-no" title="statement not covered" >this.unexpected(refShorthandDefaultPos.start);<span class="cstat-no" title="statement not covered" >i</span></span>f(update)<span class="cstat-no" title="statement not covered" >this.checkLVal(node.argument);e</span>lse <span class="cstat-no" title="statement not covered" >if(this.strict&amp;&amp;node.operator==="delete"&amp;&amp;node.argument.type==="Identifier")<span class="cstat-no" title="statement not covered" >this.raise(node.start,"Deleting local variable in strict mode");<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn this.finishNode(node,update?"UpdateExpression":"UnaryExpression");}</span></span>
<span class="cstat-no" title="statement not covered" >var startPos=this.start,startLoc=this.startLoc;<span class="cstat-no" title="statement not covered" >v</span>ar expr=this.parseExprSubscripts(refShorthandDefaultPos);<span class="cstat-no" title="statement not covered" >i</span>f(refShorthandDefaultPos&amp;&amp;refShorthandDefaultPos.start)<span class="cstat-no" title="statement not covered" >return expr;<span class="cstat-no" title="statement not covered" >w</span></span>hile(this.type.postfix&amp;&amp;!this.canInsertSemicolon()){<span class="cstat-no" title="statement not covered" >var node=this.startNodeAt(startPos,startLoc);<span class="cstat-no" title="statement not covered" >n</span>ode.operator=this.value;<span class="cstat-no" title="statement not covered" >n</span>ode.prefix=false;<span class="cstat-no" title="statement not covered" >n</span>ode.argument=expr;<span class="cstat-no" title="statement not covered" >t</span>his.checkLVal(expr);<span class="cstat-no" title="statement not covered" >t</span>his.next();<span class="cstat-no" title="statement not covered" >e</span>xpr=this.finishNode(node,"UpdateExpression");}</span></span>
<span class="cstat-no" title="statement not covered" >return expr;}</span>;pp.parseExprSubscripts=<span class="fstat-no" title="function not covered" >function(refShorthandDefaultPos){<span class="cstat-no" title="statement not covered" ></span>var startPos=this.start,startLoc=this.startLoc;<span class="cstat-no" title="statement not covered" >v</span>ar expr=this.parseExprAtom(refShorthandDefaultPos);<span class="cstat-no" title="statement not covered" >i</span>f(refShorthandDefaultPos&amp;&amp;refShorthandDefaultPos.start)<span class="cstat-no" title="statement not covered" >return expr;<span class="cstat-no" title="statement not covered" >r</span></span>eturn this.parseSubscripts(expr,startPos,startLoc);}</span>;pp.parseSubscripts=<span class="fstat-no" title="function not covered" >function(base,startPos,startLoc,noCalls){<span class="cstat-no" title="statement not covered" ></span>for(;;){<span class="cstat-no" title="statement not covered" >if(this.eat(_tokentype.types.dot)){<span class="cstat-no" title="statement not covered" >var node=this.startNodeAt(startPos,startLoc);<span class="cstat-no" title="statement not covered" >n</span>ode.object=base;<span class="cstat-no" title="statement not covered" >n</span>ode.property=this.parseIdent(true);<span class="cstat-no" title="statement not covered" >n</span>ode.computed=false;<span class="cstat-no" title="statement not covered" >b</span>ase=this.finishNode(node,"MemberExpression");}</span>else <span class="cstat-no" title="statement not covered" >if(this.eat(_tokentype.types.bracketL)){<span class="cstat-no" title="statement not covered" >var node=this.startNodeAt(startPos,startLoc);<span class="cstat-no" title="statement not covered" >n</span>ode.object=base;<span class="cstat-no" title="statement not covered" >n</span>ode.property=this.parseExpression();<span class="cstat-no" title="statement not covered" >n</span>ode.computed=true;<span class="cstat-no" title="statement not covered" >t</span>his.expect(_tokentype.types.bracketR);<span class="cstat-no" title="statement not covered" >b</span>ase=this.finishNode(node,"MemberExpression");}</span>else <span class="cstat-no" title="statement not covered" >if(!noCalls&amp;&amp;this.eat(_tokentype.types.parenL)){<span class="cstat-no" title="statement not covered" >var node=this.startNodeAt(startPos,startLoc);<span class="cstat-no" title="statement not covered" >n</span>ode.callee=base;<span class="cstat-no" title="statement not covered" >n</span>ode.arguments=this.parseExprList(_tokentype.types.parenR,false);<span class="cstat-no" title="statement not covered" >b</span>ase=this.finishNode(node,"CallExpression");}</span>else <span class="cstat-no" title="statement not covered" >if(this.type===_tokentype.types.backQuote){<span class="cstat-no" title="statement not covered" >var node=this.startNodeAt(startPos,startLoc);<span class="cstat-no" title="statement not covered" >n</span>ode.tag=base;<span class="cstat-no" title="statement not covered" >n</span>ode.quasi=this.parseTemplate();<span class="cstat-no" title="statement not covered" >b</span>ase=this.finishNode(node,"TaggedTemplateExpression");}</span>else{<span class="cstat-no" title="statement not covered" >return base;}</span>}</span></span></span></span>}</span>;pp.parseExprAtom=<span class="fstat-no" title="function not covered" >function(refShorthandDefaultPos){<span class="cstat-no" title="statement not covered" ></span>var node=undefined,canBeArrow=this.potentialArrowAt==this.start;<span class="cstat-no" title="statement not covered" >s</span>witch(this.type){case _tokentype.types._super:<span class="cstat-no" title="statement not covered" >if(!this.inFunction)<span class="cstat-no" title="statement not covered" >this.raise(this.start,"'super' outside of function or class");c</span></span>ase _tokentype.types._this:<span class="cstat-no" title="statement not covered" >var type=this.type===_tokentype.types._this?"ThisExpression":"Super";<span class="cstat-no" title="statement not covered" >n</span>ode=this.startNode();<span class="cstat-no" title="statement not covered" >t</span>his.next();<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishNode(node,type);c</span>ase _tokentype.types._yield:<span class="cstat-no" title="statement not covered" >if(this.inGenerator)<span class="cstat-no" title="statement not covered" >this.unexpected();c</span></span>ase _tokentype.types.name:<span class="cstat-no" title="statement not covered" >var startPos=this.start,startLoc=this.startLoc;<span class="cstat-no" title="statement not covered" >v</span>ar id=this.parseIdent(this.type!==_tokentype.types.name);<span class="cstat-no" title="statement not covered" >i</span>f(canBeArrow&amp;&amp;!this.canInsertSemicolon()&amp;&amp;this.eat(_tokentype.types.arrow))<span class="cstat-no" title="statement not covered" >return this.parseArrowExpression(this.startNodeAt(startPos,startLoc),[id]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn id;c</span>ase _tokentype.types.regexp:<span class="cstat-no" title="statement not covered" >var value=this.value;<span class="cstat-no" title="statement not covered" >n</span>ode=this.parseLiteral(value.value);<span class="cstat-no" title="statement not covered" >n</span>ode.regex={pattern:value.pattern,flags:value.flags};<span class="cstat-no" title="statement not covered" >r</span>eturn node;c</span>ase _tokentype.types.num:case _tokentype.types.string:<span class="cstat-no" title="statement not covered" >return this.parseLiteral(this.value);c</span>ase _tokentype.types._null:case _tokentype.types._true:case _tokentype.types._false:<span class="cstat-no" title="statement not covered" >node=this.startNode();<span class="cstat-no" title="statement not covered" >n</span>ode.value=this.type===_tokentype.types._null?null:this.type===_tokentype.types._true;<span class="cstat-no" title="statement not covered" >n</span>ode.raw=this.type.keyword;<span class="cstat-no" title="statement not covered" >t</span>his.next();<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishNode(node,"Literal");c</span>ase _tokentype.types.parenL:<span class="cstat-no" title="statement not covered" >return this.parseParenAndDistinguishExpression(canBeArrow);c</span>ase _tokentype.types.bracketL:<span class="cstat-no" title="statement not covered" >node=this.startNode();<span class="cstat-no" title="statement not covered" >t</span>his.next();<span class="cstat-no" title="statement not covered" >i</span>f(this.options.ecmaVersion&gt;=7&amp;&amp;this.type===_tokentype.types._for){<span class="cstat-no" title="statement not covered" >return this.parseComprehension(node,false);}</span></span></span>
<span class="cstat-no" title="statement not covered" >node.elements=this.parseExprList(_tokentype.types.bracketR,true,true,refShorthandDefaultPos);<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishNode(node,"ArrayExpression");c</span>ase _tokentype.types.braceL:<span class="cstat-no" title="statement not covered" >return this.parseObj(false,refShorthandDefaultPos);c</span>ase _tokentype.types._function:<span class="cstat-no" title="statement not covered" >node=this.startNode();<span class="cstat-no" title="statement not covered" >t</span>his.next();<span class="cstat-no" title="statement not covered" >r</span>eturn this.parseFunction(node,false);c</span>ase _tokentype.types._class:<span class="cstat-no" title="statement not covered" >return this.parseClass(this.startNode(),false);c</span>ase _tokentype.types._new:<span class="cstat-no" title="statement not covered" >return this.parseNew();c</span>ase _tokentype.types.backQuote:<span class="cstat-no" title="statement not covered" >return this.parseTemplate();d</span>efault:<span class="cstat-no" title="statement not covered" >this.unexpected();}</span>};pp.parseLiteral=<span class="fstat-no" title="function not covered" >function(value){<span class="cstat-no" title="statement not covered" ></span>var node=this.startNode();<span class="cstat-no" title="statement not covered" >n</span>ode.value=value;<span class="cstat-no" title="statement not covered" >n</span>ode.raw=this.input.slice(this.start,this.end);<span class="cstat-no" title="statement not covered" >t</span>his.next();<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishNode(node,"Literal");}</span>;pp.parseParenExpression=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>this.expect(_tokentype.types.parenL);<span class="cstat-no" title="statement not covered" >v</span>ar val=this.parseExpression();<span class="cstat-no" title="statement not covered" >t</span>his.expect(_tokentype.types.parenR);<span class="cstat-no" title="statement not covered" >r</span>eturn val;}</span>;pp.parseParenAndDistinguishExpression=<span class="fstat-no" title="function not covered" >function(canBeArrow){<span class="cstat-no" title="statement not covered" ></span>var startPos=this.start,startLoc=this.startLoc,val=undefined;<span class="cstat-no" title="statement not covered" >i</span>f(this.options.ecmaVersion&gt;=6){<span class="cstat-no" title="statement not covered" >this.next();<span class="cstat-no" title="statement not covered" >i</span>f(this.options.ecmaVersion&gt;=7&amp;&amp;this.type===_tokentype.types._for){<span class="cstat-no" title="statement not covered" >return this.parseComprehension(this.startNodeAt(startPos,startLoc),true);}</span></span></span>
<span class="cstat-no" title="statement not covered" >var innerStartPos=this.start,innerStartLoc=this.startLoc;<span class="cstat-no" title="statement not covered" >v</span>ar exprList=[],first=true;<span class="cstat-no" title="statement not covered" >v</span>ar refShorthandDefaultPos={start:0},spreadStart=undefined,innerParenStart=undefined;<span class="cstat-no" title="statement not covered" >w</span>hile(this.type!==_tokentype.types.parenR){<span class="cstat-no" title="statement not covered" >first?first=false:this.expect(_tokentype.types.comma);<span class="cstat-no" title="statement not covered" >i</span>f(this.type===_tokentype.types.ellipsis){<span class="cstat-no" title="statement not covered" >spreadStart=this.start;<span class="cstat-no" title="statement not covered" >e</span>xprList.push(this.parseParenItem(this.parseRest()));<span class="cstat-no" title="statement not covered" >b</span>reak;}</span>else{<span class="cstat-no" title="statement not covered" >if(this.type===_tokentype.types.parenL&amp;&amp;!innerParenStart){<span class="cstat-no" title="statement not covered" >innerParenStart=this.start;}</span></span></span></span>
<span class="cstat-no" title="statement not covered" >exprList.push(this.parseMaybeAssign(false,refShorthandDefaultPos,this.parseParenItem));}</span>}
<span class="cstat-no" title="statement not covered" >var innerEndPos=this.start,innerEndLoc=this.startLoc;<span class="cstat-no" title="statement not covered" >t</span>his.expect(_tokentype.types.parenR);<span class="cstat-no" title="statement not covered" >i</span>f(canBeArrow&amp;&amp;!this.canInsertSemicolon()&amp;&amp;this.eat(_tokentype.types.arrow)){<span class="cstat-no" title="statement not covered" >if(innerParenStart)<span class="cstat-no" title="statement not covered" >this.unexpected(innerParenStart);<span class="cstat-no" title="statement not covered" >r</span></span>eturn this.parseParenArrowList(startPos,startLoc,exprList);}</span></span>
<span class="cstat-no" title="statement not covered" >if(!exprList.length)<span class="cstat-no" title="statement not covered" >this.unexpected(this.lastTokStart);<span class="cstat-no" title="statement not covered" >i</span></span>f(spreadStart)<span class="cstat-no" title="statement not covered" >this.unexpected(spreadStart);<span class="cstat-no" title="statement not covered" >i</span></span>f(refShorthandDefaultPos.start)<span class="cstat-no" title="statement not covered" >this.unexpected(refShorthandDefaultPos.start);<span class="cstat-no" title="statement not covered" >i</span></span>f(exprList.length&gt;1){<span class="cstat-no" title="statement not covered" >val=this.startNodeAt(innerStartPos,innerStartLoc);<span class="cstat-no" title="statement not covered" >v</span>al.expressions=exprList;<span class="cstat-no" title="statement not covered" >t</span>his.finishNodeAt(val,"SequenceExpression",innerEndPos,innerEndLoc);}</span>else{<span class="cstat-no" title="statement not covered" >val=exprList[0];}</span>}</span>else{<span class="cstat-no" title="statement not covered" >val=this.parseParenExpression();}</span>
<span class="cstat-no" title="statement not covered" >if(this.options.preserveParens){<span class="cstat-no" title="statement not covered" >var par=this.startNodeAt(startPos,startLoc);<span class="cstat-no" title="statement not covered" >p</span>ar.expression=val;<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishNode(par,"ParenthesizedExpression");}</span>else{<span class="cstat-no" title="statement not covered" >return val;}</span>}</span>;pp.parseParenItem=<span class="fstat-no" title="function not covered" >function(item){<span class="cstat-no" title="statement not covered" ></span>return item;}</span>;pp.parseParenArrowList=<span class="fstat-no" title="function not covered" >function(startPos,startLoc,exprList){<span class="cstat-no" title="statement not covered" ></span>return this.parseArrowExpression(this.startNodeAt(startPos,startLoc),exprList);}</span>;var empty=[];pp.parseNew=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>var node=this.startNode();<span class="cstat-no" title="statement not covered" >v</span>ar meta=this.parseIdent(true);<span class="cstat-no" title="statement not covered" >i</span>f(this.options.ecmaVersion&gt;=6&amp;&amp;this.eat(_tokentype.types.dot)){<span class="cstat-no" title="statement not covered" >node.meta=meta;<span class="cstat-no" title="statement not covered" >n</span>ode.property=this.parseIdent(true);<span class="cstat-no" title="statement not covered" >i</span>f(node.property.name!=="target")<span class="cstat-no" title="statement not covered" >this.raise(node.property.start,"The only valid meta property for new is new.target");<span class="cstat-no" title="statement not covered" >i</span></span>f(!this.inFunction)<span class="cstat-no" title="statement not covered" >this.raise(node.start,"new.target can only be used in functions");<span class="cstat-no" title="statement not covered" >r</span></span>eturn this.finishNode(node,"MetaProperty");}</span></span>
<span class="cstat-no" title="statement not covered" >var startPos=this.start,startLoc=this.startLoc;<span class="cstat-no" title="statement not covered" >n</span>ode.callee=this.parseSubscripts(this.parseExprAtom(),startPos,startLoc,true);<span class="cstat-no" title="statement not covered" >i</span>f(this.eat(_tokentype.types.parenL))<span class="cstat-no" title="statement not covered" >node.arguments=this.parseExprList(_tokentype.types.parenR,false);e</span>lse <span class="cstat-no" title="statement not covered" >node.arguments=empty;<span class="cstat-no" title="statement not covered" >r</span></span>eturn this.finishNode(node,"NewExpression");}</span>;pp.parseTemplateElement=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>var elem=this.startNode();<span class="cstat-no" title="statement not covered" >e</span>lem.value={raw:this.input.slice(this.start,this.end).replace(/\r\n?/g,'\n'),cooked:this.value};<span class="cstat-no" title="statement not covered" >t</span>his.next();<span class="cstat-no" title="statement not covered" >e</span>lem.tail=this.type===_tokentype.types.backQuote;<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishNode(elem,"TemplateElement");}</span>;pp.parseTemplate=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>var node=this.startNode();<span class="cstat-no" title="statement not covered" >t</span>his.next();<span class="cstat-no" title="statement not covered" >n</span>ode.expressions=[];<span class="cstat-no" title="statement not covered" >v</span>ar curElt=this.parseTemplateElement();<span class="cstat-no" title="statement not covered" >n</span>ode.quasis=[curElt];<span class="cstat-no" title="statement not covered" >w</span>hile(!curElt.tail){<span class="cstat-no" title="statement not covered" >this.expect(_tokentype.types.dollarBraceL);<span class="cstat-no" title="statement not covered" >n</span>ode.expressions.push(this.parseExpression());<span class="cstat-no" title="statement not covered" >t</span>his.expect(_tokentype.types.braceR);<span class="cstat-no" title="statement not covered" >n</span>ode.quasis.push(curElt=this.parseTemplateElement());}</span></span>
<span class="cstat-no" title="statement not covered" >this.next();<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishNode(node,"TemplateLiteral");}</span>;pp.parseObj=<span class="fstat-no" title="function not covered" >function(isPattern,refShorthandDefaultPos){<span class="cstat-no" title="statement not covered" ></span>var node=this.startNode(),first=true,propHash={};<span class="cstat-no" title="statement not covered" >n</span>ode.properties=[];<span class="cstat-no" title="statement not covered" >t</span>his.next();<span class="cstat-no" title="statement not covered" >w</span>hile(!this.eat(_tokentype.types.braceR)){<span class="cstat-no" title="statement not covered" >if(!first){<span class="cstat-no" title="statement not covered" >this.expect(_tokentype.types.comma);<span class="cstat-no" title="statement not covered" >i</span>f(this.afterTrailingComma(_tokentype.types.braceR))<span class="cstat-no" title="statement not covered" >break;}</span></span>else <span class="cstat-no" title="statement not covered" >first=false;<span class="cstat-no" title="statement not covered" >v</span></span>ar prop=this.startNode(),isGenerator=undefined,startPos=undefined,startLoc=undefined;<span class="cstat-no" title="statement not covered" >i</span>f(this.options.ecmaVersion&gt;=6){<span class="cstat-no" title="statement not covered" >prop.method=false;<span class="cstat-no" title="statement not covered" >p</span>rop.shorthand=false;<span class="cstat-no" title="statement not covered" >i</span>f(isPattern||refShorthandDefaultPos){<span class="cstat-no" title="statement not covered" >startPos=this.start;<span class="cstat-no" title="statement not covered" >s</span>tartLoc=this.startLoc;}</span></span></span></span>
<span class="cstat-no" title="statement not covered" >if(!isPattern)<span class="cstat-no" title="statement not covered" >isGenerator=this.eat(_tokentype.types.star);}</span></span>
<span class="cstat-no" title="statement not covered" >this.parsePropertyName(prop);<span class="cstat-no" title="statement not covered" >t</span>his.parsePropertyValue(prop,isPattern,isGenerator,startPos,startLoc,refShorthandDefaultPos);<span class="cstat-no" title="statement not covered" >t</span>his.checkPropClash(prop,propHash);<span class="cstat-no" title="statement not covered" >n</span>ode.properties.push(this.finishNode(prop,"Property"));}</span>
<span class="cstat-no" title="statement not covered" >return this.finishNode(node,isPattern?"ObjectPattern":"ObjectExpression");}</span>;pp.parsePropertyValue=<span class="fstat-no" title="function not covered" >function(prop,isPattern,isGenerator,startPos,startLoc,refShorthandDefaultPos){<span class="cstat-no" title="statement not covered" ></span>if(this.eat(_tokentype.types.colon)){<span class="cstat-no" title="statement not covered" >prop.value=isPattern?this.parseMaybeDefault(this.start,this.startLoc):this.parseMaybeAssign(false,refShorthandDefaultPos);<span class="cstat-no" title="statement not covered" >p</span>rop.kind="init";}</span>else <span class="cstat-no" title="statement not covered" >if(this.options.ecmaVersion&gt;=6&amp;&amp;this.type===_tokentype.types.parenL){<span class="cstat-no" title="statement not covered" >if(isPattern)<span class="cstat-no" title="statement not covered" >this.unexpected();<span class="cstat-no" title="statement not covered" >p</span></span>rop.kind="init";<span class="cstat-no" title="statement not covered" >p</span>rop.method=true;<span class="cstat-no" title="statement not covered" >p</span>rop.value=this.parseMethod(isGenerator);}</span>else <span class="cstat-no" title="statement not covered" >if(this.options.ecmaVersion&gt;=5&amp;&amp;!prop.computed&amp;&amp;prop.key.type==="Identifier"&amp;&amp;(prop.key.name==="get"||prop.key.name==="set")&amp;&amp;(this.type!=_tokentype.types.comma&amp;&amp;this.type!=_tokentype.types.braceR)){<span class="cstat-no" title="statement not covered" >if(isGenerator||isPattern)<span class="cstat-no" title="statement not covered" >this.unexpected();<span class="cstat-no" title="statement not covered" >p</span></span>rop.kind=prop.key.name;<span class="cstat-no" title="statement not covered" >t</span>his.parsePropertyName(prop);<span class="cstat-no" title="statement not covered" >p</span>rop.value=this.parseMethod(false);<span class="cstat-no" title="statement not covered" >v</span>ar paramCount=prop.kind==="get"?0:1;<span class="cstat-no" title="statement not covered" >i</span>f(prop.value.params.length!==paramCount){<span class="cstat-no" title="statement not covered" >var start=prop.value.start;<span class="cstat-no" title="statement not covered" >i</span>f(prop.kind==="get")<span class="cstat-no" title="statement not covered" >this.raise(start,"getter should have no params");e</span>lse <span class="cstat-no" title="statement not covered" >this.raise(start,"setter should have exactly one param");}</span></span>}</span>else <span class="cstat-no" title="statement not covered" >if(this.options.ecmaVersion&gt;=6&amp;&amp;!prop.computed&amp;&amp;prop.key.type==="Identifier"){<span class="cstat-no" title="statement not covered" >prop.kind="init";<span class="cstat-no" title="statement not covered" >i</span>f(isPattern){<span class="cstat-no" title="statement not covered" >if(this.keywords.test(prop.key.name)||(this.strict?this.reservedWordsStrictBind:this.reservedWords).test(prop.key.name))<span class="cstat-no" title="statement not covered" >this.raise(prop.key.start,"Binding "+prop.key.name);<span class="cstat-no" title="statement not covered" >p</span></span>rop.value=this.parseMaybeDefault(startPos,startLoc,prop.key);}</span>else <span class="cstat-no" title="statement not covered" >if(this.type===_tokentype.types.eq&amp;&amp;refShorthandDefaultPos){<span class="cstat-no" title="statement not covered" >if(!refShorthandDefaultPos.start)<span class="cstat-no" title="statement not covered" >refShorthandDefaultPos.start=this.start;<span class="cstat-no" title="statement not covered" >p</span></span>rop.value=this.parseMaybeDefault(startPos,startLoc,prop.key);}</span>else{<span class="cstat-no" title="statement not covered" >prop.value=prop.key;}</span></span></span></span></span></span></span>
<span class="cstat-no" title="statement not covered" >prop.shorthand=true;}</span>else <span class="cstat-no" title="statement not covered" >this.unexpected();}</span>;pp.parsePropertyName=<span class="fstat-no" title="function not covered" >function(prop){<span class="cstat-no" title="statement not covered" ></span>if(this.options.ecmaVersion&gt;=6){<span class="cstat-no" title="statement not covered" >if(this.eat(_tokentype.types.bracketL)){<span class="cstat-no" title="statement not covered" >prop.computed=true;<span class="cstat-no" title="statement not covered" >p</span>rop.key=this.parseMaybeAssign();<span class="cstat-no" title="statement not covered" >t</span>his.expect(_tokentype.types.bracketR);<span class="cstat-no" title="statement not covered" >r</span>eturn prop.key;}</span>else{<span class="cstat-no" title="statement not covered" >prop.computed=false;}</span>}</span></span>
<span class="cstat-no" title="statement not covered" >return prop.key=this.type===_tokentype.types.num||this.type===_tokentype.types.string?this.parseExprAtom():this.parseIdent(true);}</span>;pp.initFunction=<span class="fstat-no" title="function not covered" >function(node){<span class="cstat-no" title="statement not covered" ></span>node.id=null;<span class="cstat-no" title="statement not covered" >i</span>f(this.options.ecmaVersion&gt;=6){<span class="cstat-no" title="statement not covered" >node.generator=false;<span class="cstat-no" title="statement not covered" >n</span>ode.expression=false;}</span>}</span>;pp.parseMethod=<span class="fstat-no" title="function not covered" >function(isGenerator){<span class="cstat-no" title="statement not covered" ></span>var node=this.startNode();<span class="cstat-no" title="statement not covered" >t</span>his.initFunction(node);<span class="cstat-no" title="statement not covered" >t</span>his.expect(_tokentype.types.parenL);<span class="cstat-no" title="statement not covered" >n</span>ode.params=this.parseBindingList(_tokentype.types.parenR,false,false);<span class="cstat-no" title="statement not covered" >i</span>f(this.options.ecmaVersion&gt;=6)<span class="cstat-no" title="statement not covered" >node.generator=isGenerator;<span class="cstat-no" title="statement not covered" >t</span></span>his.parseFunctionBody(node,false);<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishNode(node,"FunctionExpression");}</span>;pp.parseArrowExpression=<span class="fstat-no" title="function not covered" >function(node,params){<span class="cstat-no" title="statement not covered" ></span>this.initFunction(node);<span class="cstat-no" title="statement not covered" >n</span>ode.params=this.toAssignableList(params,true);<span class="cstat-no" title="statement not covered" >t</span>his.parseFunctionBody(node,true);<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishNode(node,"ArrowFunctionExpression");}</span>;pp.parseFunctionBody=<span class="fstat-no" title="function not covered" >function(node,isArrowFunction){<span class="cstat-no" title="statement not covered" ></span>var isExpression=isArrowFunction&amp;&amp;this.type!==_tokentype.types.braceL;<span class="cstat-no" title="statement not covered" >i</span>f(isExpression){<span class="cstat-no" title="statement not covered" >node.body=this.parseMaybeAssign();<span class="cstat-no" title="statement not covered" >n</span>ode.expression=true;}</span>else{<span class="cstat-no" title="statement not covered" >var oldInFunc=this.inFunction,oldInGen=this.inGenerator,oldLabels=this.labels;<span class="cstat-no" title="statement not covered" >t</span>his.inFunction=true;<span class="cstat-no" title="statement not covered" >t</span>his.inGenerator=node.generator;<span class="cstat-no" title="statement not covered" >t</span>his.labels=[];<span class="cstat-no" title="statement not covered" >n</span>ode.body=this.parseBlock(true);<span class="cstat-no" title="statement not covered" >n</span>ode.expression=false;<span class="cstat-no" title="statement not covered" >t</span>his.inFunction=oldInFunc;<span class="cstat-no" title="statement not covered" >t</span>his.inGenerator=oldInGen;<span class="cstat-no" title="statement not covered" >t</span>his.labels=oldLabels;}</span></span>
<span class="cstat-no" title="statement not covered" >if(this.strict||!isExpression&amp;&amp;node.body.body.length&amp;&amp;this.isUseStrict(node.body.body[0])){<span class="cstat-no" title="statement not covered" >var oldStrict=this.strict;<span class="cstat-no" title="statement not covered" >t</span>his.strict=true;<span class="cstat-no" title="statement not covered" >i</span>f(node.id)<span class="cstat-no" title="statement not covered" >this.checkLVal(node.id,true);<span class="cstat-no" title="statement not covered" >t</span></span>his.checkParams(node);<span class="cstat-no" title="statement not covered" >t</span>his.strict=oldStrict;}</span>else <span class="cstat-no" title="statement not covered" >if(isArrowFunction){<span class="cstat-no" title="statement not covered" >this.checkParams(node);}</span>}</span></span>;pp.checkParams=<span class="fstat-no" title="function not covered" >function(node){<span class="cstat-no" title="statement not covered" ></span>var nameHash={};<span class="cstat-no" title="statement not covered" >f</span>or(var i=0;i&lt;node.params.length;i++){<span class="cstat-no" title="statement not covered" >this.checkLVal(node.params[i],true,nameHash);}</span>}</span>;pp.parseExprList=<span class="fstat-no" title="function not covered" >function(close,allowTrailingComma,allowEmpty,refShorthandDefaultPos){<span class="cstat-no" title="statement not covered" ></span>var elts=[],first=true;<span class="cstat-no" title="statement not covered" >w</span>hile(!this.eat(close)){<span class="cstat-no" title="statement not covered" >if(!first){<span class="cstat-no" title="statement not covered" >this.expect(_tokentype.types.comma);<span class="cstat-no" title="statement not covered" >i</span>f(allowTrailingComma&amp;&amp;this.afterTrailingComma(close))<span class="cstat-no" title="statement not covered" >break;}</span></span>else <span class="cstat-no" title="statement not covered" >first=false;<span class="cstat-no" title="statement not covered" >v</span></span>ar elt=undefined;<span class="cstat-no" title="statement not covered" >i</span>f(allowEmpty&amp;&amp;this.type===_tokentype.types.comma)<span class="cstat-no" title="statement not covered" >elt=null;e</span>lse <span class="cstat-no" title="statement not covered" >if(this.type===_tokentype.types.ellipsis)<span class="cstat-no" title="statement not covered" >elt=this.parseSpread(refShorthandDefaultPos);e</span>lse <span class="cstat-no" title="statement not covered" >elt=this.parseMaybeAssign(false,refShorthandDefaultPos);<span class="cstat-no" title="statement not covered" >e</span></span></span>lts.push(elt);}</span></span>
<span class="cstat-no" title="statement not covered" >return elts;}</span>;pp.parseIdent=<span class="fstat-no" title="function not covered" >function(liberal){<span class="cstat-no" title="statement not covered" ></span>var node=this.startNode();<span class="cstat-no" title="statement not covered" >i</span>f(liberal&amp;&amp;this.options.allowReserved=="never")<span class="cstat-no" title="statement not covered" >liberal=false;<span class="cstat-no" title="statement not covered" >i</span></span>f(this.type===_tokentype.types.name){<span class="cstat-no" title="statement not covered" >if(!liberal&amp;&amp;(this.strict?this.reservedWordsStrict:this.reservedWords).test(this.value)&amp;&amp;(this.options.ecmaVersion&gt;=6||this.input.slice(this.start,this.end).indexOf("\\")==-1))<span class="cstat-no" title="statement not covered" >this.raise(this.start,"The keyword '"+this.value+"' is reserved");<span class="cstat-no" title="statement not covered" >n</span></span>ode.name=this.value;}</span>else <span class="cstat-no" title="statement not covered" >if(liberal&amp;&amp;this.type.keyword){<span class="cstat-no" title="statement not covered" >node.name=this.type.keyword;}</span>else{<span class="cstat-no" title="statement not covered" >this.unexpected();}</span></span></span>
<span class="cstat-no" title="statement not covered" >this.next();<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishNode(node,"Identifier");}</span>;pp.parseYield=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>var node=this.startNode();<span class="cstat-no" title="statement not covered" >t</span>his.next();<span class="cstat-no" title="statement not covered" >i</span>f(this.type==_tokentype.types.semi||this.canInsertSemicolon()||this.type!=_tokentype.types.star&amp;&amp;!this.type.startsExpr){<span class="cstat-no" title="statement not covered" >node.delegate=false;<span class="cstat-no" title="statement not covered" >n</span>ode.argument=null;}</span>else{<span class="cstat-no" title="statement not covered" >node.delegate=this.eat(_tokentype.types.star);<span class="cstat-no" title="statement not covered" >n</span>ode.argument=this.parseMaybeAssign();}</span></span>
<span class="cstat-no" title="statement not covered" >return this.finishNode(node,"YieldExpression");}</span>;pp.parseComprehension=<span class="fstat-no" title="function not covered" >function(node,isGenerator){<span class="cstat-no" title="statement not covered" ></span>node.blocks=[];<span class="cstat-no" title="statement not covered" >w</span>hile(this.type===_tokentype.types._for){<span class="cstat-no" title="statement not covered" >var block=this.startNode();<span class="cstat-no" title="statement not covered" >t</span>his.next();<span class="cstat-no" title="statement not covered" >t</span>his.expect(_tokentype.types.parenL);<span class="cstat-no" title="statement not covered" >b</span>lock.left=this.parseBindingAtom();<span class="cstat-no" title="statement not covered" >t</span>his.checkLVal(block.left,true);<span class="cstat-no" title="statement not covered" >t</span>his.expectContextual("of");<span class="cstat-no" title="statement not covered" >b</span>lock.right=this.parseExpression();<span class="cstat-no" title="statement not covered" >t</span>his.expect(_tokentype.types.parenR);<span class="cstat-no" title="statement not covered" >n</span>ode.blocks.push(this.finishNode(block,"ComprehensionBlock"));}</span></span>
<span class="cstat-no" title="statement not covered" >node.filter=this.eat(_tokentype.types._if)?this.parseParenExpression():null;<span class="cstat-no" title="statement not covered" >n</span>ode.body=this.parseExpression();<span class="cstat-no" title="statement not covered" >t</span>his.expect(isGenerator?_tokentype.types.parenR:_tokentype.types.bracketR);<span class="cstat-no" title="statement not covered" >n</span>ode.generator=isGenerator;<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishNode(node,"ComprehensionExpression");}</span>;},{"./state":10,"./tokentype":14}],2:[function(_dereq_,module,exports){"use strict";exports.__esModule=true;exports.isIdentifierStart=isIdentifierStart;exports.isIdentifierChar=isIdentifierChar;var reservedWords={3:"abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",5:"class enum extends super const export import",6:"enum",strict:"implements interface let package private protected public static yield",strictBind:"eval arguments"};exports.reservedWords=reservedWords;var ecma5AndLessKeywords="break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";var keywords={5:ecma5AndLessKeywords,6:ecma5AndLessKeywords+" let const class extends export import yield super"};exports.keywords=keywords;var nonASCIIidentifierStartChars="-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------";var nonASCIIidentifierChars="-------------------------------------------------------------------------------------------------------------------------------------------------";var nonASCIIidentifierStart=new RegExp("["+nonASCIIidentifierStartChars+"]");var nonASCIIidentifier=new RegExp("["+nonASCIIidentifierStartChars+nonASCIIidentifierChars+"]");nonASCIIidentifierStartChars=nonASCIIidentifierChars=null;var astralIdentifierStartCodes=[0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,17,26,6,37,11,29,3,35,5,7,2,4,43,157,99,39,9,51,157,310,10,21,11,7,153,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,98,21,11,25,71,55,7,1,65,0,16,3,2,2,2,26,45,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,955,52,76,44,33,24,27,35,42,34,4,0,13,47,15,3,22,0,38,17,2,24,133,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,32,4,287,47,21,1,2,0,185,46,82,47,21,0,60,42,502,63,32,0,449,56,1288,920,104,110,2962,1070,13266,568,8,30,114,29,19,47,17,3,32,20,6,18,881,68,12,0,67,12,16481,1,3071,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,4149,196,1340,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42710,42,4148,12,221,16355,541];var astralIdentifierCodes=[509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,1306,2,54,14,32,9,16,3,46,10,54,9,7,2,37,13,2,9,52,0,13,2,49,13,16,9,83,11,168,11,6,9,8,2,57,0,2,6,3,1,3,2,10,0,11,1,3,6,4,4,316,19,13,9,214,6,3,8,112,16,16,9,82,12,9,9,535,9,20855,9,135,4,60,6,26,9,1016,45,17,3,19723,1,5319,4,4,5,9,7,3,6,31,3,149,2,1418,49,4305,6,792618,239];<span class="fstat-no" title="function not covered" >function isInAstralSet(code,set){<span class="cstat-no" title="statement not covered" ></span>var pos=0x10000;<span class="cstat-no" title="statement not covered" >f</span>or(var i=0;i&lt;set.length;i+=2){<span class="cstat-no" title="statement not covered" >pos+=set[i];<span class="cstat-no" title="statement not covered" >i</span>f(pos&gt;code)<span class="cstat-no" title="statement not covered" >return false;<span class="cstat-no" title="statement not covered" >p</span></span>os+=set[i+1];<span class="cstat-no" title="statement not covered" >i</span>f(pos&gt;=code)<span class="cstat-no" title="statement not covered" >return true;}</span></span>}</span>
<span class="fstat-no" title="function not covered" >function isIdentifierStart(code,astral){<span class="cstat-no" title="statement not covered" ></span>if(code&lt;65)<span class="cstat-no" title="statement not covered" >return code===36;<span class="cstat-no" title="statement not covered" >i</span></span>f(code&lt;91)<span class="cstat-no" title="statement not covered" >return true;<span class="cstat-no" title="statement not covered" >i</span></span>f(code&lt;97)<span class="cstat-no" title="statement not covered" >return code===95;<span class="cstat-no" title="statement not covered" >i</span></span>f(code&lt;123)<span class="cstat-no" title="statement not covered" >return true;<span class="cstat-no" title="statement not covered" >i</span></span>f(code&lt;=0xffff)<span class="cstat-no" title="statement not covered" >return code&gt;=0xaa&amp;&amp;nonASCIIidentifierStart.test(String.fromCharCode(code));<span class="cstat-no" title="statement not covered" >i</span></span>f(astral===false)<span class="cstat-no" title="statement not covered" >return false;<span class="cstat-no" title="statement not covered" >r</span></span>eturn isInAstralSet(code,astralIdentifierStartCodes);}</span>
<span class="fstat-no" title="function not covered" >function isIdentifierChar(code,astral){<span class="cstat-no" title="statement not covered" ></span>if(code&lt;48)<span class="cstat-no" title="statement not covered" >return code===36;<span class="cstat-no" title="statement not covered" >i</span></span>f(code&lt;58)<span class="cstat-no" title="statement not covered" >return true;<span class="cstat-no" title="statement not covered" >i</span></span>f(code&lt;65)<span class="cstat-no" title="statement not covered" >return false;<span class="cstat-no" title="statement not covered" >i</span></span>f(code&lt;91)<span class="cstat-no" title="statement not covered" >return true;<span class="cstat-no" title="statement not covered" >i</span></span>f(code&lt;97)<span class="cstat-no" title="statement not covered" >return code===95;<span class="cstat-no" title="statement not covered" >i</span></span>f(code&lt;123)<span class="cstat-no" title="statement not covered" >return true;<span class="cstat-no" title="statement not covered" >i</span></span>f(code&lt;=0xffff)<span class="cstat-no" title="statement not covered" >return code&gt;=0xaa&amp;&amp;nonASCIIidentifier.test(String.fromCharCode(code));<span class="cstat-no" title="statement not covered" >i</span></span>f(astral===false)<span class="cstat-no" title="statement not covered" >return false;<span class="cstat-no" title="statement not covered" >r</span></span>eturn isInAstralSet(code,astralIdentifierStartCodes)||isInAstralSet(code,astralIdentifierCodes);}</span>},{}],3:[function(_dereq_,module,exports){"use strict";exports.__esModule=true;exports.parse=parse;exports.parseExpressionAt=parseExpressionAt;exports.tokenizer=tokenizer;var _state=_dereq_("./state");_dereq_("./parseutil");_dereq_("./statement");_dereq_("./lval");_dereq_("./expression");_dereq_("./location");exports.Parser=_state.Parser;exports.plugins=_state.plugins;var _options=_dereq_("./options");exports.defaultOptions=_options.defaultOptions;var _locutil=_dereq_("./locutil");exports.Position=_locutil.Position;exports.SourceLocation=_locutil.SourceLocation;exports.getLineInfo=_locutil.getLineInfo;var _node=_dereq_("./node");exports.Node=_node.Node;var _tokentype=_dereq_("./tokentype");exports.TokenType=_tokentype.TokenType;exports.tokTypes=_tokentype.types;var _tokencontext=_dereq_("./tokencontext");exports.TokContext=_tokencontext.TokContext;exports.tokContexts=_tokencontext.types;var _identifier=_dereq_("./identifier");exports.isIdentifierChar=_identifier.isIdentifierChar;exports.isIdentifierStart=_identifier.isIdentifierStart;var _tokenize=_dereq_("./tokenize");exports.Token=_tokenize.Token;var _whitespace=_dereq_("./whitespace");exports.isNewLine=_whitespace.isNewLine;exports.lineBreak=_whitespace.lineBreak;exports.lineBreakG=_whitespace.lineBreakG;var version="2.4.1";exports.version=version;<span class="fstat-no" title="function not covered" >function parse(input,options){<span class="cstat-no" title="statement not covered" ></span>return new _state.Parser(options,input).parse();}</span>
<span class="fstat-no" title="function not covered" >function parseExpressionAt(input,pos,options){<span class="cstat-no" title="statement not covered" ></span>var p=new _state.Parser(options,input,pos);<span class="cstat-no" title="statement not covered" >p</span>.nextToken();<span class="cstat-no" title="statement not covered" >r</span>eturn p.parseExpression();}</span>
<span class="fstat-no" title="function not covered" >function tokenizer(input,options){<span class="cstat-no" title="statement not covered" ></span>return new _state.Parser(options,input);}</span>},{"./expression":1,"./identifier":2,"./location":4,"./locutil":5,"./lval":6,"./node":7,"./options":8,"./parseutil":9,"./state":10,"./statement":11,"./tokencontext":12,"./tokenize":13,"./tokentype":14,"./whitespace":16}],4:[function(_dereq_,module,exports){"use strict";var _state=_dereq_("./state");var _locutil=_dereq_("./locutil");var pp=_state.Parser.prototype;pp.raise=<span class="fstat-no" title="function not covered" >function(pos,message){<span class="cstat-no" title="statement not covered" ></span>var loc=_locutil.getLineInfo(this.input,pos);<span class="cstat-no" title="statement not covered" >m</span>essage+=" ("+loc.line+":"+loc.column+")";<span class="cstat-no" title="statement not covered" >v</span>ar err=new SyntaxError(message);<span class="cstat-no" title="statement not covered" >e</span>rr.pos=pos;<span class="cstat-no" title="statement not covered" >e</span>rr.loc=loc;<span class="cstat-no" title="statement not covered" >e</span>rr.raisedAt=this.pos;<span class="cstat-no" title="statement not covered" >t</span>hrow err;}</span>;pp.curPosition=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>if(this.options.locations){<span class="cstat-no" title="statement not covered" >return new _locutil.Position(this.curLine,this.pos-this.lineStart);}</span>}</span>;},{"./locutil":5,"./state":10}],5:[function(_dereq_,module,exports){"use strict";exports.__esModule=true;exports.getLineInfo=getLineInfo;<span class="fstat-no" title="function not covered" >function _classCallCheck(instance,Constructor){<span class="cstat-no" title="statement not covered" ></span>if(!(instance instanceof Constructor)){<span class="cstat-no" title="statement not covered" >throw new TypeError("Cannot call a class as a function");}</span>}</span>
var _whitespace=_dereq_("./whitespace");var Position=(function(){<span class="fstat-no" title="function not covered" >function Position(line,col){<span class="cstat-no" title="statement not covered" ></span>_classCallCheck(this,Position);<span class="cstat-no" title="statement not covered" >t</span>his.line=line;<span class="cstat-no" title="statement not covered" >t</span>his.column=col;}</span>
Position.prototype.offset=<span class="fstat-no" title="function not covered" >function offset(n){<span class="cstat-no" title="statement not covered" ></span>return new Position(this.line,this.column+n);}</span>;return Position;})();exports.Position=Position;var SourceLocation=<span class="fstat-no" title="function not covered" >function SourceLocation(p,start,end){<span class="cstat-no" title="statement not covered" ></span>_classCallCheck(this,SourceLocation);<span class="cstat-no" title="statement not covered" >t</span>his.start=start;<span class="cstat-no" title="statement not covered" >t</span>his.end=end;<span class="cstat-no" title="statement not covered" >i</span>f(p.sourceFile!==null)<span class="cstat-no" title="statement not covered" >this.source=p.sourceFile;}</span></span>;exports.SourceLocation=SourceLocation;<span class="fstat-no" title="function not covered" >function getLineInfo(input,offset){<span class="cstat-no" title="statement not covered" ></span>for(var line=1,cur=0;;){<span class="cstat-no" title="statement not covered" >_whitespace.lineBreakG.lastIndex=cur;<span class="cstat-no" title="statement not covered" >v</span>ar match=_whitespace.lineBreakG.exec(input);<span class="cstat-no" title="statement not covered" >i</span>f(match&amp;&amp;match.index&lt;offset){<span class="cstat-no" title="statement not covered" >++line;<span class="cstat-no" title="statement not covered" >c</span>ur=match.index+match[0].length;}</span>else{<span class="cstat-no" title="statement not covered" >return new Position(line,offset-cur);}</span>}</span>}</span>},{"./whitespace":16}],6:[function(_dereq_,module,exports){"use strict";var _tokentype=_dereq_("./tokentype");var _state=_dereq_("./state");var _util=_dereq_("./util");var pp=_state.Parser.prototype;pp.toAssignable=<span class="fstat-no" title="function not covered" >function(node,isBinding){<span class="cstat-no" title="statement not covered" ></span>if(this.options.ecmaVersion&gt;=6&amp;&amp;node){<span class="cstat-no" title="statement not covered" >switch(node.type){case"Identifier":case"ObjectPattern":case"ArrayPattern":case"AssignmentPattern":<span class="cstat-no" title="statement not covered" >break;c</span>ase"ObjectExpression":<span class="cstat-no" title="statement not covered" >node.type="ObjectPattern";<span class="cstat-no" title="statement not covered" >f</span>or(var i=0;i&lt;node.properties.length;i++){<span class="cstat-no" title="statement not covered" >var prop=node.properties[i];<span class="cstat-no" title="statement not covered" >i</span>f(prop.kind!=="init")<span class="cstat-no" title="statement not covered" >this.raise(prop.key.start,"Object pattern can't contain getter or setter");<span class="cstat-no" title="statement not covered" >t</span></span>his.toAssignable(prop.value,isBinding);}</span></span></span></span>
<span class="cstat-no" title="statement not covered" >break;c</span>ase"ArrayExpression":<span class="cstat-no" title="statement not covered" >node.type="ArrayPattern";<span class="cstat-no" title="statement not covered" >t</span>his.toAssignableList(node.elements,isBinding);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"AssignmentExpression":<span class="cstat-no" title="statement not covered" >if(node.operator==="="){<span class="cstat-no" title="statement not covered" >node.type="AssignmentPattern";<span class="cstat-no" title="statement not covered" >d</span>elete node.operator;}</span>else{<span class="cstat-no" title="statement not covered" >this.raise(node.left.end,"Only '=' operator can be used for specifying default value.");}</span></span>
<span class="cstat-no" title="statement not covered" >break;c</span>ase"ParenthesizedExpression":<span class="cstat-no" title="statement not covered" >node.expression=this.toAssignable(node.expression,isBinding);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"MemberExpression":<span class="cstat-no" title="statement not covered" >if(!isBinding)<span class="cstat-no" title="statement not covered" >break;d</span></span>efault:<span class="cstat-no" title="statement not covered" >this.raise(node.start,"Assigning to rvalue");}</span>}
<span class="cstat-no" title="statement not covered" >return node;}</span>;pp.toAssignableList=<span class="fstat-no" title="function not covered" >function(exprList,isBinding){<span class="cstat-no" title="statement not covered" ></span>var end=exprList.length;<span class="cstat-no" title="statement not covered" >i</span>f(end){<span class="cstat-no" title="statement not covered" >var last=exprList[end-1];<span class="cstat-no" title="statement not covered" >i</span>f(last&amp;&amp;last.type=="RestElement"){<span class="cstat-no" title="statement not covered" >--end;}</span>else <span class="cstat-no" title="statement not covered" >if(last&amp;&amp;last.type=="SpreadElement"){<span class="cstat-no" title="statement not covered" >last.type="RestElement";<span class="cstat-no" title="statement not covered" >v</span>ar arg=last.argument;<span class="cstat-no" title="statement not covered" >t</span>his.toAssignable(arg,isBinding);<span class="cstat-no" title="statement not covered" >i</span>f(arg.type!=="Identifier"&amp;&amp;arg.type!=="MemberExpression"&amp;&amp;arg.type!=="ArrayPattern")<span class="cstat-no" title="statement not covered" >this.unexpected(arg.start);<span class="cstat-no" title="statement not covered" >-</span></span>-end;}</span></span></span></span>
<span class="cstat-no" title="statement not covered" >if(isBinding&amp;&amp;last.type==="RestElement"&amp;&amp;last.argument.type!=="Identifier")<span class="cstat-no" title="statement not covered" >this.unexpected(last.argument.start);}</span></span>
<span class="cstat-no" title="statement not covered" >for(var i=0;i&lt;end;i++){<span class="cstat-no" title="statement not covered" >var elt=exprList[i];<span class="cstat-no" title="statement not covered" >i</span>f(elt)<span class="cstat-no" title="statement not covered" >this.toAssignable(elt,isBinding);}</span></span></span>
<span class="cstat-no" title="statement not covered" >return exprList;}</span>;pp.parseSpread=<span class="fstat-no" title="function not covered" >function(refShorthandDefaultPos){<span class="cstat-no" title="statement not covered" ></span>var node=this.startNode();<span class="cstat-no" title="statement not covered" >t</span>his.next();<span class="cstat-no" title="statement not covered" >n</span>ode.argument=this.parseMaybeAssign(refShorthandDefaultPos);<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishNode(node,"SpreadElement");}</span>;pp.parseRest=<span class="fstat-no" title="function not covered" >function(allowNonIdent){<span class="cstat-no" title="statement not covered" ></span>var node=this.startNode();<span class="cstat-no" title="statement not covered" >t</span>his.next();<span class="cstat-no" title="statement not covered" >i</span>f(allowNonIdent)<span class="cstat-no" title="statement not covered" >node.argument=this.type===_tokentype.types.name?this.parseIdent():this.unexpected();e</span>lse <span class="cstat-no" title="statement not covered" >node.argument=this.type===_tokentype.types.name||this.type===_tokentype.types.bracketL?this.parseBindingAtom():this.unexpected();<span class="cstat-no" title="statement not covered" >r</span></span>eturn this.finishNode(node,"RestElement");}</span>;pp.parseBindingAtom=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>if(this.options.ecmaVersion&lt;6)<span class="cstat-no" title="statement not covered" >return this.parseIdent();<span class="cstat-no" title="statement not covered" >s</span></span>witch(this.type){case _tokentype.types.name:<span class="cstat-no" title="statement not covered" >return this.parseIdent();c</span>ase _tokentype.types.bracketL:<span class="cstat-no" title="statement not covered" >var node=this.startNode();<span class="cstat-no" title="statement not covered" >t</span>his.next();<span class="cstat-no" title="statement not covered" >n</span>ode.elements=this.parseBindingList(_tokentype.types.bracketR,true,true);<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishNode(node,"ArrayPattern");c</span>ase _tokentype.types.braceL:<span class="cstat-no" title="statement not covered" >return this.parseObj(true);d</span>efault:<span class="cstat-no" title="statement not covered" >this.unexpected();}</span>}</span>;pp.parseBindingList=<span class="fstat-no" title="function not covered" >function(close,allowEmpty,allowTrailingComma,allowNonIdent){<span class="cstat-no" title="statement not covered" ></span>var elts=[],first=true;<span class="cstat-no" title="statement not covered" >w</span>hile(!this.eat(close)){<span class="cstat-no" title="statement not covered" >if(first)<span class="cstat-no" title="statement not covered" >first=false;e</span>lse <span class="cstat-no" title="statement not covered" >this.expect(_tokentype.types.comma);<span class="cstat-no" title="statement not covered" >i</span></span>f(allowEmpty&amp;&amp;this.type===_tokentype.types.comma){<span class="cstat-no" title="statement not covered" >elts.push(null);}</span>else <span class="cstat-no" title="statement not covered" >if(allowTrailingComma&amp;&amp;this.afterTrailingComma(close)){<span class="cstat-no" title="statement not covered" >break;}</span>else <span class="cstat-no" title="statement not covered" >if(this.type===_tokentype.types.ellipsis){<span class="cstat-no" title="statement not covered" >var rest=this.parseRest(allowNonIdent);<span class="cstat-no" title="statement not covered" >t</span>his.parseBindingListItem(rest);<span class="cstat-no" title="statement not covered" >e</span>lts.push(rest);<span class="cstat-no" title="statement not covered" >t</span>his.expect(close);<span class="cstat-no" title="statement not covered" >b</span>reak;}</span>else{<span class="cstat-no" title="statement not covered" >var elem=this.parseMaybeDefault(this.start,this.startLoc);<span class="cstat-no" title="statement not covered" >t</span>his.parseBindingListItem(elem);<span class="cstat-no" title="statement not covered" >e</span>lts.push(elem);}</span>}</span></span></span></span>
<span class="cstat-no" title="statement not covered" >return elts;}</span>;pp.parseBindingListItem=<span class="fstat-no" title="function not covered" >function(param){<span class="cstat-no" title="statement not covered" ></span>return param;}</span>;pp.parseMaybeDefault=<span class="fstat-no" title="function not covered" >function(startPos,startLoc,left){<span class="cstat-no" title="statement not covered" ></span>left=left||this.parseBindingAtom();<span class="cstat-no" title="statement not covered" >i</span>f(this.options.ecmaVersion&lt;6||!this.eat(_tokentype.types.eq))<span class="cstat-no" title="statement not covered" >return left;<span class="cstat-no" title="statement not covered" >v</span></span>ar node=this.startNodeAt(startPos,startLoc);<span class="cstat-no" title="statement not covered" >n</span>ode.left=left;<span class="cstat-no" title="statement not covered" >n</span>ode.right=this.parseMaybeAssign();<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishNode(node,"AssignmentPattern");}</span>;pp.checkLVal=<span class="fstat-no" title="function not covered" >function(expr,isBinding,checkClashes){<span class="cstat-no" title="statement not covered" ></span>switch(expr.type){case"Identifier":<span class="cstat-no" title="statement not covered" >if(this.strict&amp;&amp;this.reservedWordsStrictBind.test(expr.name))<span class="cstat-no" title="statement not covered" >this.raise(expr.start,(isBinding?"Binding ":"Assigning to ")+expr.name+" in strict mode");<span class="cstat-no" title="statement not covered" >i</span></span>f(checkClashes){<span class="cstat-no" title="statement not covered" >if(_util.has(checkClashes,expr.name))<span class="cstat-no" title="statement not covered" >this.raise(expr.start,"Argument name clash");<span class="cstat-no" title="statement not covered" >c</span></span>heckClashes[expr.name]=true;}</span></span></span>
<span class="cstat-no" title="statement not covered" >break;c</span>ase"MemberExpression":<span class="cstat-no" title="statement not covered" >if(isBinding)<span class="cstat-no" title="statement not covered" >this.raise(expr.start,(isBinding?"Binding":"Assigning to")+" member expression");<span class="cstat-no" title="statement not covered" >b</span></span>reak;c</span>ase"ObjectPattern":<span class="cstat-no" title="statement not covered" >for(var i=0;i&lt;expr.properties.length;i++){<span class="cstat-no" title="statement not covered" >this.checkLVal(expr.properties[i].value,isBinding,checkClashes);}<span class="cstat-no" title="statement not covered" ></span>b</span>reak;c</span>ase"ArrayPattern":<span class="cstat-no" title="statement not covered" >for(var i=0;i&lt;expr.elements.length;i++){<span class="cstat-no" title="statement not covered" >var elem=expr.elements[i];<span class="cstat-no" title="statement not covered" >i</span>f(elem)<span class="cstat-no" title="statement not covered" >this.checkLVal(elem,isBinding,checkClashes);}</span></span></span>
<span class="cstat-no" title="statement not covered" >break;c</span>ase"AssignmentPattern":<span class="cstat-no" title="statement not covered" >this.checkLVal(expr.left,isBinding,checkClashes);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"RestElement":<span class="cstat-no" title="statement not covered" >this.checkLVal(expr.argument,isBinding,checkClashes);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"ParenthesizedExpression":<span class="cstat-no" title="statement not covered" >this.checkLVal(expr.expression,isBinding,checkClashes);<span class="cstat-no" title="statement not covered" >b</span>reak;d</span>efault:<span class="cstat-no" title="statement not covered" >this.raise(expr.start,(isBinding?"Binding":"Assigning to")+" rvalue");}</span>};},{"./state":10,"./tokentype":14,"./util":15}],7:[function(_dereq_,module,exports){"use strict";exports.__esModule=true;<span class="fstat-no" title="function not covered" >function _classCallCheck(instance,Constructor){<span class="cstat-no" title="statement not covered" ></span>if(!(instance instanceof Constructor)){<span class="cstat-no" title="statement not covered" >throw new TypeError("Cannot call a class as a function");}</span>}</span>
var _state=_dereq_("./state");var _locutil=_dereq_("./locutil");var Node=<span class="fstat-no" title="function not covered" >function Node(parser,pos,loc){<span class="cstat-no" title="statement not covered" ></span>_classCallCheck(this,Node);<span class="cstat-no" title="statement not covered" >t</span>his.type="";<span class="cstat-no" title="statement not covered" >t</span>his.start=pos;<span class="cstat-no" title="statement not covered" >t</span>his.end=0;<span class="cstat-no" title="statement not covered" >i</span>f(parser.options.locations)<span class="cstat-no" title="statement not covered" >this.loc=new _locutil.SourceLocation(parser,loc);<span class="cstat-no" title="statement not covered" >i</span></span>f(parser.options.directSourceFile)<span class="cstat-no" title="statement not covered" >this.sourceFile=parser.options.directSourceFile;<span class="cstat-no" title="statement not covered" >i</span></span>f(parser.options.ranges)<span class="cstat-no" title="statement not covered" >this.range=[pos,0];}</span></span>;exports.Node=Node;var pp=_state.Parser.prototype;pp.startNode=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>return new Node(this,this.start,this.startLoc);}</span>;pp.startNodeAt=<span class="fstat-no" title="function not covered" >function(pos,loc){<span class="cstat-no" title="statement not covered" ></span>return new Node(this,pos,loc);}</span>;<span class="fstat-no" title="function not covered" >function finishNodeAt(node,type,pos,loc){<span class="cstat-no" title="statement not covered" ></span>node.type=type;<span class="cstat-no" title="statement not covered" >n</span>ode.end=pos;<span class="cstat-no" title="statement not covered" >i</span>f(this.options.locations)<span class="cstat-no" title="statement not covered" >node.loc.end=loc;<span class="cstat-no" title="statement not covered" >i</span></span>f(this.options.ranges)<span class="cstat-no" title="statement not covered" >node.range[1]=pos;<span class="cstat-no" title="statement not covered" >r</span></span>eturn node;}</span>
pp.finishNode=<span class="fstat-no" title="function not covered" >function(node,type){<span class="cstat-no" title="statement not covered" ></span>return finishNodeAt.call(this,node,type,this.lastTokEnd,this.lastTokEndLoc);}</span>;pp.finishNodeAt=<span class="fstat-no" title="function not covered" >function(node,type,pos,loc){<span class="cstat-no" title="statement not covered" ></span>return finishNodeAt.call(this,node,type,pos,loc);}</span>;},{"./locutil":5,"./state":10}],8:[function(_dereq_,module,exports){"use strict";exports.__esModule=true;exports.getOptions=getOptions;var _util=_dereq_("./util");var _locutil=_dereq_("./locutil");var defaultOptions={ecmaVersion:5,sourceType:"script",onInsertedSemicolon:null,onTrailingComma:null,allowReserved:null,allowReturnOutsideFunction:false,allowImportExportEverywhere:false,allowHashBang:false,locations:false,onToken:null,onComment:null,ranges:false,program:null,sourceFile:null,directSourceFile:null,preserveParens:false,plugins:{}};exports.defaultOptions=defaultOptions;<span class="fstat-no" title="function not covered" >function getOptions(opts){<span class="cstat-no" title="statement not covered" ></span>var options={};<span class="cstat-no" title="statement not covered" >f</span>or(var opt in defaultOptions){<span class="cstat-no" title="statement not covered" >options[opt]=opts&amp;&amp;_util.has(opts,opt)?opts[opt]:defaultOptions[opt];}<span class="cstat-no" title="statement not covered" ></span>i</span>f(options.allowReserved==null)<span class="cstat-no" title="statement not covered" >options.allowReserved=options.ecmaVersion&gt;=5;<span class="cstat-no" title="statement not covered" >i</span></span>f(_util.isArray(options.onToken)){<span class="cstat-no" title="statement not covered" >(<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>var tokens=options.onToken;<span class="cstat-no" title="statement not covered" >o</span>ptions.onToken=<span class="fstat-no" title="function not covered" >function(token){<span class="cstat-no" title="statement not covered" ></span>return tokens.push(token);}</span>;}</span>)();}</span></span>
<span class="cstat-no" title="statement not covered" >if(_util.isArray(options.onComment))<span class="cstat-no" title="statement not covered" >options.onComment=pushComment(options,options.onComment);<span class="cstat-no" title="statement not covered" >r</span></span>eturn options;}</span>
<span class="fstat-no" title="function not covered" >function pushComment(options,array){<span class="cstat-no" title="statement not covered" ></span>return <span class="fstat-no" title="function not covered" >function(block,text,start,end,startLoc,endLoc){<span class="cstat-no" title="statement not covered" ></span>var comment={type:block?'Block':'Line',value:text,start:start,end:end};<span class="cstat-no" title="statement not covered" >i</span>f(options.locations)<span class="cstat-no" title="statement not covered" >comment.loc=new _locutil.SourceLocation(this,startLoc,endLoc);<span class="cstat-no" title="statement not covered" >i</span></span>f(options.ranges)<span class="cstat-no" title="statement not covered" >comment.range=[start,end];<span class="cstat-no" title="statement not covered" >a</span></span>rray.push(comment);}</span>;}</span>},{"./locutil":5,"./util":15}],9:[function(_dereq_,module,exports){"use strict";var _tokentype=_dereq_("./tokentype");var _state=_dereq_("./state");var _whitespace=_dereq_("./whitespace");var pp=_state.Parser.prototype;pp.isUseStrict=<span class="fstat-no" title="function not covered" >function(stmt){<span class="cstat-no" title="statement not covered" ></span>return this.options.ecmaVersion&gt;=5&amp;&amp;stmt.type==="ExpressionStatement"&amp;&amp;stmt.expression.type==="Literal"&amp;&amp;stmt.expression.raw.slice(1,-1)==="use strict";}</span>;pp.eat=<span class="fstat-no" title="function not covered" >function(type){<span class="cstat-no" title="statement not covered" ></span>if(this.type===type){<span class="cstat-no" title="statement not covered" >this.next();<span class="cstat-no" title="statement not covered" >r</span>eturn true;}</span>else{<span class="cstat-no" title="statement not covered" >return false;}</span>}</span>;pp.isContextual=<span class="fstat-no" title="function not covered" >function(name){<span class="cstat-no" title="statement not covered" ></span>return this.type===_tokentype.types.name&amp;&amp;this.value===name;}</span>;pp.eatContextual=<span class="fstat-no" title="function not covered" >function(name){<span class="cstat-no" title="statement not covered" ></span>return this.value===name&amp;&amp;this.eat(_tokentype.types.name);}</span>;pp.expectContextual=<span class="fstat-no" title="function not covered" >function(name){<span class="cstat-no" title="statement not covered" ></span>if(!this.eatContextual(name))<span class="cstat-no" title="statement not covered" >this.unexpected();}</span></span>;pp.canInsertSemicolon=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>return this.type===_tokentype.types.eof||this.type===_tokentype.types.braceR||_whitespace.lineBreak.test(this.input.slice(this.lastTokEnd,this.start));}</span>;pp.insertSemicolon=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>if(this.canInsertSemicolon()){<span class="cstat-no" title="statement not covered" >if(this.options.onInsertedSemicolon)<span class="cstat-no" title="statement not covered" >this.options.onInsertedSemicolon(this.lastTokEnd,this.lastTokEndLoc);<span class="cstat-no" title="statement not covered" >r</span></span>eturn true;}</span>}</span>;pp.semicolon=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>if(!this.eat(_tokentype.types.semi)&amp;&amp;!this.insertSemicolon())<span class="cstat-no" title="statement not covered" >this.unexpected();}</span></span>;pp.afterTrailingComma=<span class="fstat-no" title="function not covered" >function(tokType){<span class="cstat-no" title="statement not covered" ></span>if(this.type==tokType){<span class="cstat-no" title="statement not covered" >if(this.options.onTrailingComma)<span class="cstat-no" title="statement not covered" >this.options.onTrailingComma(this.lastTokStart,this.lastTokStartLoc);<span class="cstat-no" title="statement not covered" >t</span></span>his.next();<span class="cstat-no" title="statement not covered" >r</span>eturn true;}</span>}</span>;pp.expect=<span class="fstat-no" title="function not covered" >function(type){<span class="cstat-no" title="statement not covered" ></span>this.eat(type)||this.unexpected();}</span>;pp.unexpected=<span class="fstat-no" title="function not covered" >function(pos){<span class="cstat-no" title="statement not covered" ></span>this.raise(pos!=null?pos:this.start,"Unexpected token");}</span>;},{"./state":10,"./tokentype":14,"./whitespace":16}],10:[function(_dereq_,module,exports){"use strict";exports.__esModule=true;<span class="fstat-no" title="function not covered" >function _classCallCheck(instance,Constructor){<span class="cstat-no" title="statement not covered" ></span>if(!(instance instanceof Constructor)){<span class="cstat-no" title="statement not covered" >throw new TypeError("Cannot call a class as a function");}</span>}</span>
var _identifier=_dereq_("./identifier");var _tokentype=_dereq_("./tokentype");var _whitespace=_dereq_("./whitespace");var _options=_dereq_("./options");var plugins={};exports.plugins=plugins;<span class="fstat-no" title="function not covered" >function keywordRegexp(words){<span class="cstat-no" title="statement not covered" ></span>return new RegExp("^("+words.replace(/ /g,"|")+")$");}</span>
var Parser=(function(){<span class="fstat-no" title="function not covered" >function Parser(options,input,startPos){<span class="cstat-no" title="statement not covered" ></span>_classCallCheck(this,Parser);<span class="cstat-no" title="statement not covered" >t</span>his.options=_options.getOptions(options);<span class="cstat-no" title="statement not covered" >t</span>his.sourceFile=this.options.sourceFile;<span class="cstat-no" title="statement not covered" >t</span>his.keywords=keywordRegexp(_identifier.keywords[this.options.ecmaVersion&gt;=6?6:5]);<span class="cstat-no" title="statement not covered" >v</span>ar reserved=this.options.allowReserved?"":_identifier.reservedWords[this.options.ecmaVersion]+(options.sourceType=="module"?" await":"");<span class="cstat-no" title="statement not covered" >t</span>his.reservedWords=keywordRegexp(reserved);<span class="cstat-no" title="statement not covered" >v</span>ar reservedStrict=(reserved?reserved+" ":"")+_identifier.reservedWords.strict;<span class="cstat-no" title="statement not covered" >t</span>his.reservedWordsStrict=keywordRegexp(reservedStrict);<span class="cstat-no" title="statement not covered" >t</span>his.reservedWordsStrictBind=keywordRegexp(reservedStrict+" "+_identifier.reservedWords.strictBind);<span class="cstat-no" title="statement not covered" >t</span>his.input=String(input);<span class="cstat-no" title="statement not covered" >t</span>his.containsEsc=false;<span class="cstat-no" title="statement not covered" >t</span>his.loadPlugins(this.options.plugins);<span class="cstat-no" title="statement not covered" >i</span>f(startPos){<span class="cstat-no" title="statement not covered" >this.pos=startPos;<span class="cstat-no" title="statement not covered" >t</span>his.lineStart=Math.max(0,this.input.lastIndexOf("\n",startPos));<span class="cstat-no" title="statement not covered" >t</span>his.curLine=this.input.slice(0,this.lineStart).split(_whitespace.lineBreak).length;}</span>else{<span class="cstat-no" title="statement not covered" >this.pos=this.lineStart=0;<span class="cstat-no" title="statement not covered" >t</span>his.curLine=1;}</span></span>
<span class="cstat-no" title="statement not covered" >this.type=_tokentype.types.eof;<span class="cstat-no" title="statement not covered" >t</span>his.value=null;<span class="cstat-no" title="statement not covered" >t</span>his.start=this.end=this.pos;<span class="cstat-no" title="statement not covered" >t</span>his.startLoc=this.endLoc=this.curPosition();<span class="cstat-no" title="statement not covered" >t</span>his.lastTokEndLoc=this.lastTokStartLoc=null;<span class="cstat-no" title="statement not covered" >t</span>his.lastTokStart=this.lastTokEnd=this.pos;<span class="cstat-no" title="statement not covered" >t</span>his.context=this.initialContext();<span class="cstat-no" title="statement not covered" >t</span>his.exprAllowed=true;<span class="cstat-no" title="statement not covered" >t</span>his.strict=this.inModule=this.options.sourceType==="module";<span class="cstat-no" title="statement not covered" >t</span>his.potentialArrowAt=-1;<span class="cstat-no" title="statement not covered" >t</span>his.inFunction=this.inGenerator=false;<span class="cstat-no" title="statement not covered" >t</span>his.labels=[];<span class="cstat-no" title="statement not covered" >i</span>f(this.pos===0&amp;&amp;this.options.allowHashBang&amp;&amp;this.input.slice(0,2)==='#!')<span class="cstat-no" title="statement not covered" >this.skipLineComment(2);}</span></span>
Parser.prototype.isKeyword=<span class="fstat-no" title="function not covered" >function isKeyword(word){<span class="cstat-no" title="statement not covered" ></span>return this.keywords.test(word);}</span>;Parser.prototype.isReservedWord=<span class="fstat-no" title="function not covered" >function isReservedWord(word){<span class="cstat-no" title="statement not covered" ></span>return this.reservedWords.test(word);}</span>;Parser.prototype.extend=<span class="fstat-no" title="function not covered" >function extend(name,f){<span class="cstat-no" title="statement not covered" ></span>this[name]=f(this[name]);}</span>;Parser.prototype.loadPlugins=<span class="fstat-no" title="function not covered" >function loadPlugins(pluginConfigs){<span class="cstat-no" title="statement not covered" ></span>for(var _name in pluginConfigs){<span class="cstat-no" title="statement not covered" >var plugin=plugins[_name];<span class="cstat-no" title="statement not covered" >i</span>f(!plugin)<span class="cstat-no" title="statement not covered" >throw new Error("Plugin '"+_name+"' not found");<span class="cstat-no" title="statement not covered" >p</span></span>lugin(this,pluginConfigs[_name]);}</span>}</span>;Parser.prototype.parse=<span class="fstat-no" title="function not covered" >function parse(){<span class="cstat-no" title="statement not covered" ></span>var node=this.options.program||this.startNode();<span class="cstat-no" title="statement not covered" >t</span>his.nextToken();<span class="cstat-no" title="statement not covered" >r</span>eturn this.parseTopLevel(node);}</span>;return Parser;})();exports.Parser=Parser;},{"./identifier":2,"./options":8,"./tokentype":14,"./whitespace":16}],11:[function(_dereq_,module,exports){"use strict";var _tokentype=_dereq_("./tokentype");var _state=_dereq_("./state");var _whitespace=_dereq_("./whitespace");var pp=_state.Parser.prototype;pp.parseTopLevel=<span class="fstat-no" title="function not covered" >function(node){<span class="cstat-no" title="statement not covered" ></span>var first=true;<span class="cstat-no" title="statement not covered" >i</span>f(!node.body)<span class="cstat-no" title="statement not covered" >node.body=[];<span class="cstat-no" title="statement not covered" >w</span></span>hile(this.type!==_tokentype.types.eof){<span class="cstat-no" title="statement not covered" >var stmt=this.parseStatement(true,true);<span class="cstat-no" title="statement not covered" >n</span>ode.body.push(stmt);<span class="cstat-no" title="statement not covered" >i</span>f(first){<span class="cstat-no" title="statement not covered" >if(this.isUseStrict(stmt))<span class="cstat-no" title="statement not covered" >this.setStrict(true);<span class="cstat-no" title="statement not covered" >f</span></span>irst=false;}</span>}</span></span>
<span class="cstat-no" title="statement not covered" >this.next();<span class="cstat-no" title="statement not covered" >i</span>f(this.options.ecmaVersion&gt;=6){<span class="cstat-no" title="statement not covered" >node.sourceType=this.options.sourceType;}</span></span>
<span class="cstat-no" title="statement not covered" >return this.finishNode(node,"Program");}</span>;var loopLabel={kind:"loop"},switchLabel={kind:"switch"};pp.parseStatement=<span class="fstat-no" title="function not covered" >function(declaration,topLevel){<span class="cstat-no" title="statement not covered" ></span>var starttype=this.type,node=this.startNode();<span class="cstat-no" title="statement not covered" >s</span>witch(starttype){case _tokentype.types._break:case _tokentype.types._continue:<span class="cstat-no" title="statement not covered" >return this.parseBreakContinueStatement(node,starttype.keyword);c</span>ase _tokentype.types._debugger:<span class="cstat-no" title="statement not covered" >return this.parseDebuggerStatement(node);c</span>ase _tokentype.types._do:<span class="cstat-no" title="statement not covered" >return this.parseDoStatement(node);c</span>ase _tokentype.types._for:<span class="cstat-no" title="statement not covered" >return this.parseForStatement(node);c</span>ase _tokentype.types._function:<span class="cstat-no" title="statement not covered" >if(!declaration&amp;&amp;this.options.ecmaVersion&gt;=6)<span class="cstat-no" title="statement not covered" >this.unexpected();<span class="cstat-no" title="statement not covered" >r</span></span>eturn this.parseFunctionStatement(node);c</span>ase _tokentype.types._class:<span class="cstat-no" title="statement not covered" >if(!declaration)<span class="cstat-no" title="statement not covered" >this.unexpected();<span class="cstat-no" title="statement not covered" >r</span></span>eturn this.parseClass(node,true);c</span>ase _tokentype.types._if:<span class="cstat-no" title="statement not covered" >return this.parseIfStatement(node);c</span>ase _tokentype.types._return:<span class="cstat-no" title="statement not covered" >return this.parseReturnStatement(node);c</span>ase _tokentype.types._switch:<span class="cstat-no" title="statement not covered" >return this.parseSwitchStatement(node);c</span>ase _tokentype.types._throw:<span class="cstat-no" title="statement not covered" >return this.parseThrowStatement(node);c</span>ase _tokentype.types._try:<span class="cstat-no" title="statement not covered" >return this.parseTryStatement(node);c</span>ase _tokentype.types._let:case _tokentype.types._const:<span class="cstat-no" title="statement not covered" >if(!declaration)<span class="cstat-no" title="statement not covered" >this.unexpected();c</span></span>ase _tokentype.types._var:<span class="cstat-no" title="statement not covered" >return this.parseVarStatement(node,starttype);c</span>ase _tokentype.types._while:<span class="cstat-no" title="statement not covered" >return this.parseWhileStatement(node);c</span>ase _tokentype.types._with:<span class="cstat-no" title="statement not covered" >return this.parseWithStatement(node);c</span>ase _tokentype.types.braceL:<span class="cstat-no" title="statement not covered" >return this.parseBlock();c</span>ase _tokentype.types.semi:<span class="cstat-no" title="statement not covered" >return this.parseEmptyStatement(node);c</span>ase _tokentype.types._export:case _tokentype.types._import:<span class="cstat-no" title="statement not covered" >if(!this.options.allowImportExportEverywhere){<span class="cstat-no" title="statement not covered" >if(!topLevel)<span class="cstat-no" title="statement not covered" >this.raise(this.start,"'import' and 'export' may only appear at the top level");<span class="cstat-no" title="statement not covered" >i</span></span>f(!this.inModule)<span class="cstat-no" title="statement not covered" >this.raise(this.start,"'import' and 'export' may appear only with 'sourceType: module'");}</span></span></span></span>
<span class="cstat-no" title="statement not covered" >return starttype===_tokentype.types._import?this.parseImport(node):this.parseExport(node);d</span>efault:<span class="cstat-no" title="statement not covered" >var maybeName=this.value,expr=this.parseExpression();<span class="cstat-no" title="statement not covered" >i</span>f(starttype===_tokentype.types.name&amp;&amp;expr.type==="Identifier"&amp;&amp;this.eat(_tokentype.types.colon))<span class="cstat-no" title="statement not covered" >return this.parseLabeledStatement(node,maybeName,expr);e</span>lse <span class="cstat-no" title="statement not covered" >return this.parseExpressionStatement(node,expr);}</span></span>};pp.parseBreakContinueStatement=<span class="fstat-no" title="function not covered" >function(node,keyword){<span class="cstat-no" title="statement not covered" ></span>var isBreak=keyword=="break";<span class="cstat-no" title="statement not covered" >t</span>his.next();<span class="cstat-no" title="statement not covered" >i</span>f(this.eat(_tokentype.types.semi)||this.insertSemicolon())<span class="cstat-no" title="statement not covered" >node.label=null;e</span>lse <span class="cstat-no" title="statement not covered" >if(this.type!==_tokentype.types.name)<span class="cstat-no" title="statement not covered" >this.unexpected();e</span>lse{<span class="cstat-no" title="statement not covered" >node.label=this.parseIdent();<span class="cstat-no" title="statement not covered" >t</span>his.semicolon();}</span></span></span>
<span class="cstat-no" title="statement not covered" >for(var i=0;i&lt;this.labels.length;++i){<span class="cstat-no" title="statement not covered" >var lab=this.labels[i];<span class="cstat-no" title="statement not covered" >i</span>f(node.label==null||lab.name===node.label.name){<span class="cstat-no" title="statement not covered" >if(lab.kind!=null&amp;&amp;(isBreak||lab.kind==="loop"))<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >i</span></span>f(node.label&amp;&amp;isBreak)<span class="cstat-no" title="statement not covered" >break;}</span></span>}</span></span>
<span class="cstat-no" title="statement not covered" >if(i===this.labels.length)<span class="cstat-no" title="statement not covered" >this.raise(node.start,"Unsyntactic "+keyword);<span class="cstat-no" title="statement not covered" >r</span></span>eturn this.finishNode(node,isBreak?"BreakStatement":"ContinueStatement");}</span>;pp.parseDebuggerStatement=<span class="fstat-no" title="function not covered" >function(node){<span class="cstat-no" title="statement not covered" ></span>this.next();<span class="cstat-no" title="statement not covered" >t</span>his.semicolon();<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishNode(node,"DebuggerStatement");}</span>;pp.parseDoStatement=<span class="fstat-no" title="function not covered" >function(node){<span class="cstat-no" title="statement not covered" ></span>this.next();<span class="cstat-no" title="statement not covered" >t</span>his.labels.push(loopLabel);<span class="cstat-no" title="statement not covered" >n</span>ode.body=this.parseStatement(false);<span class="cstat-no" title="statement not covered" >t</span>his.labels.pop();<span class="cstat-no" title="statement not covered" >t</span>his.expect(_tokentype.types._while);<span class="cstat-no" title="statement not covered" >n</span>ode.test=this.parseParenExpression();<span class="cstat-no" title="statement not covered" >i</span>f(this.options.ecmaVersion&gt;=6)<span class="cstat-no" title="statement not covered" >this.eat(_tokentype.types.semi);e</span>lse <span class="cstat-no" title="statement not covered" >this.semicolon();<span class="cstat-no" title="statement not covered" >r</span></span>eturn this.finishNode(node,"DoWhileStatement");}</span>;pp.parseForStatement=<span class="fstat-no" title="function not covered" >function(node){<span class="cstat-no" title="statement not covered" ></span>this.next();<span class="cstat-no" title="statement not covered" >t</span>his.labels.push(loopLabel);<span class="cstat-no" title="statement not covered" >t</span>his.expect(_tokentype.types.parenL);<span class="cstat-no" title="statement not covered" >i</span>f(this.type===_tokentype.types.semi)<span class="cstat-no" title="statement not covered" >return this.parseFor(node,null);<span class="cstat-no" title="statement not covered" >i</span></span>f(this.type===_tokentype.types._var||this.type===_tokentype.types._let||this.type===_tokentype.types._const){<span class="cstat-no" title="statement not covered" >var _init=this.startNode(),varKind=this.type;<span class="cstat-no" title="statement not covered" >t</span>his.next();<span class="cstat-no" title="statement not covered" >t</span>his.parseVar(_init,true,varKind);<span class="cstat-no" title="statement not covered" >t</span>his.finishNode(_init,"VariableDeclaration");<span class="cstat-no" title="statement not covered" >i</span>f((this.type===_tokentype.types._in||this.options.ecmaVersion&gt;=6&amp;&amp;this.isContextual("of"))&amp;&amp;_init.declarations.length===1&amp;&amp;!(varKind!==_tokentype.types._var&amp;&amp;_init.declarations[0].init))<span class="cstat-no" title="statement not covered" >return this.parseForIn(node,_init);<span class="cstat-no" title="statement not covered" >r</span></span>eturn this.parseFor(node,_init);}</span></span>
<span class="cstat-no" title="statement not covered" >var refShorthandDefaultPos={start:0};<span class="cstat-no" title="statement not covered" >v</span>ar init=this.parseExpression(true,refShorthandDefaultPos);<span class="cstat-no" title="statement not covered" >i</span>f(this.type===_tokentype.types._in||this.options.ecmaVersion&gt;=6&amp;&amp;this.isContextual("of")){<span class="cstat-no" title="statement not covered" >this.toAssignable(init);<span class="cstat-no" title="statement not covered" >t</span>his.checkLVal(init);<span class="cstat-no" title="statement not covered" >r</span>eturn this.parseForIn(node,init);}</span>else <span class="cstat-no" title="statement not covered" >if(refShorthandDefaultPos.start){<span class="cstat-no" title="statement not covered" >this.unexpected(refShorthandDefaultPos.start);}</span></span></span>
<span class="cstat-no" title="statement not covered" >return this.parseFor(node,init);}</span>;pp.parseFunctionStatement=<span class="fstat-no" title="function not covered" >function(node){<span class="cstat-no" title="statement not covered" ></span>this.next();<span class="cstat-no" title="statement not covered" >r</span>eturn this.parseFunction(node,true);}</span>;pp.parseIfStatement=<span class="fstat-no" title="function not covered" >function(node){<span class="cstat-no" title="statement not covered" ></span>this.next();<span class="cstat-no" title="statement not covered" >n</span>ode.test=this.parseParenExpression();<span class="cstat-no" title="statement not covered" >n</span>ode.consequent=this.parseStatement(false);<span class="cstat-no" title="statement not covered" >n</span>ode.alternate=this.eat(_tokentype.types._else)?this.parseStatement(false):null;<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishNode(node,"IfStatement");}</span>;pp.parseReturnStatement=<span class="fstat-no" title="function not covered" >function(node){<span class="cstat-no" title="statement not covered" ></span>if(!this.inFunction&amp;&amp;!this.options.allowReturnOutsideFunction)<span class="cstat-no" title="statement not covered" >this.raise(this.start,"'return' outside of function");<span class="cstat-no" title="statement not covered" >t</span></span>his.next();<span class="cstat-no" title="statement not covered" >i</span>f(this.eat(_tokentype.types.semi)||this.insertSemicolon())<span class="cstat-no" title="statement not covered" >node.argument=null;e</span>lse{<span class="cstat-no" title="statement not covered" >node.argument=this.parseExpression();<span class="cstat-no" title="statement not covered" >t</span>his.semicolon();}</span></span>
<span class="cstat-no" title="statement not covered" >return this.finishNode(node,"ReturnStatement");}</span>;pp.parseSwitchStatement=<span class="fstat-no" title="function not covered" >function(node){<span class="cstat-no" title="statement not covered" ></span>this.next();<span class="cstat-no" title="statement not covered" >n</span>ode.discriminant=this.parseParenExpression();<span class="cstat-no" title="statement not covered" >n</span>ode.cases=[];<span class="cstat-no" title="statement not covered" >t</span>his.expect(_tokentype.types.braceL);<span class="cstat-no" title="statement not covered" >t</span>his.labels.push(switchLabel);<span class="cstat-no" title="statement not covered" >f</span>or(var cur,sawDefault=false;this.type!=_tokentype.types.braceR;){<span class="cstat-no" title="statement not covered" >if(this.type===_tokentype.types._case||this.type===_tokentype.types._default){<span class="cstat-no" title="statement not covered" >var isCase=this.type===_tokentype.types._case;<span class="cstat-no" title="statement not covered" >i</span>f(cur)<span class="cstat-no" title="statement not covered" >this.finishNode(cur,"SwitchCase");<span class="cstat-no" title="statement not covered" >n</span></span>ode.cases.push(cur=this.startNode());<span class="cstat-no" title="statement not covered" >c</span>ur.consequent=[];<span class="cstat-no" title="statement not covered" >t</span>his.next();<span class="cstat-no" title="statement not covered" >i</span>f(isCase){<span class="cstat-no" title="statement not covered" >cur.test=this.parseExpression();}</span>else{<span class="cstat-no" title="statement not covered" >if(sawDefault)<span class="cstat-no" title="statement not covered" >this.raise(this.lastTokStart,"Multiple default clauses");<span class="cstat-no" title="statement not covered" >s</span></span>awDefault=true;<span class="cstat-no" title="statement not covered" >c</span>ur.test=null;}</span></span></span></span>
<span class="cstat-no" title="statement not covered" >this.expect(_tokentype.types.colon);}</span>else{<span class="cstat-no" title="statement not covered" >if(!cur)<span class="cstat-no" title="statement not covered" >this.unexpected();<span class="cstat-no" title="statement not covered" >c</span></span>ur.consequent.push(this.parseStatement(true));}</span>}
<span class="cstat-no" title="statement not covered" >if(cur)<span class="cstat-no" title="statement not covered" >this.finishNode(cur,"SwitchCase");<span class="cstat-no" title="statement not covered" >t</span></span>his.next();<span class="cstat-no" title="statement not covered" >t</span>his.labels.pop();<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishNode(node,"SwitchStatement");}</span>;pp.parseThrowStatement=<span class="fstat-no" title="function not covered" >function(node){<span class="cstat-no" title="statement not covered" ></span>this.next();<span class="cstat-no" title="statement not covered" >i</span>f(_whitespace.lineBreak.test(this.input.slice(this.lastTokEnd,this.start)))<span class="cstat-no" title="statement not covered" >this.raise(this.lastTokEnd,"Illegal newline after throw");<span class="cstat-no" title="statement not covered" >n</span></span>ode.argument=this.parseExpression();<span class="cstat-no" title="statement not covered" >t</span>his.semicolon();<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishNode(node,"ThrowStatement");}</span>;var empty=[];pp.parseTryStatement=<span class="fstat-no" title="function not covered" >function(node){<span class="cstat-no" title="statement not covered" ></span>this.next();<span class="cstat-no" title="statement not covered" >n</span>ode.block=this.parseBlock();<span class="cstat-no" title="statement not covered" >n</span>ode.handler=null;<span class="cstat-no" title="statement not covered" >i</span>f(this.type===_tokentype.types._catch){<span class="cstat-no" title="statement not covered" >var clause=this.startNode();<span class="cstat-no" title="statement not covered" >t</span>his.next();<span class="cstat-no" title="statement not covered" >t</span>his.expect(_tokentype.types.parenL);<span class="cstat-no" title="statement not covered" >c</span>lause.param=this.parseBindingAtom();<span class="cstat-no" title="statement not covered" >t</span>his.checkLVal(clause.param,true);<span class="cstat-no" title="statement not covered" >t</span>his.expect(_tokentype.types.parenR);<span class="cstat-no" title="statement not covered" >c</span>lause.body=this.parseBlock();<span class="cstat-no" title="statement not covered" >n</span>ode.handler=this.finishNode(clause,"CatchClause");}</span></span>
<span class="cstat-no" title="statement not covered" >node.finalizer=this.eat(_tokentype.types._finally)?this.parseBlock():null;<span class="cstat-no" title="statement not covered" >i</span>f(!node.handler&amp;&amp;!node.finalizer)<span class="cstat-no" title="statement not covered" >this.raise(node.start,"Missing catch or finally clause");<span class="cstat-no" title="statement not covered" >r</span></span>eturn this.finishNode(node,"TryStatement");}</span>;pp.parseVarStatement=<span class="fstat-no" title="function not covered" >function(node,kind){<span class="cstat-no" title="statement not covered" ></span>this.next();<span class="cstat-no" title="statement not covered" >t</span>his.parseVar(node,false,kind);<span class="cstat-no" title="statement not covered" >t</span>his.semicolon();<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishNode(node,"VariableDeclaration");}</span>;pp.parseWhileStatement=<span class="fstat-no" title="function not covered" >function(node){<span class="cstat-no" title="statement not covered" ></span>this.next();<span class="cstat-no" title="statement not covered" >n</span>ode.test=this.parseParenExpression();<span class="cstat-no" title="statement not covered" >t</span>his.labels.push(loopLabel);<span class="cstat-no" title="statement not covered" >n</span>ode.body=this.parseStatement(false);<span class="cstat-no" title="statement not covered" >t</span>his.labels.pop();<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishNode(node,"WhileStatement");}</span>;pp.parseWithStatement=<span class="fstat-no" title="function not covered" >function(node){<span class="cstat-no" title="statement not covered" ></span>if(this.strict)<span class="cstat-no" title="statement not covered" >this.raise(this.start,"'with' in strict mode");<span class="cstat-no" title="statement not covered" >t</span></span>his.next();<span class="cstat-no" title="statement not covered" >n</span>ode.object=this.parseParenExpression();<span class="cstat-no" title="statement not covered" >n</span>ode.body=this.parseStatement(false);<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishNode(node,"WithStatement");}</span>;pp.parseEmptyStatement=<span class="fstat-no" title="function not covered" >function(node){<span class="cstat-no" title="statement not covered" ></span>this.next();<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishNode(node,"EmptyStatement");}</span>;pp.parseLabeledStatement=<span class="fstat-no" title="function not covered" >function(node,maybeName,expr){<span class="cstat-no" title="statement not covered" ></span>for(var i=0;i&lt;this.labels.length;++i){<span class="cstat-no" title="statement not covered" >if(this.labels[i].name===maybeName)<span class="cstat-no" title="statement not covered" >this.raise(expr.start,"Label '"+maybeName+"' is already declared");}<span class="cstat-no" title="statement not covered" ></span></span>v</span>ar kind=this.type.isLoop?"loop":this.type===_tokentype.types._switch?"switch":null;<span class="cstat-no" title="statement not covered" >f</span>or(var i=this.labels.length-1;i&gt;=0;i--){<span class="cstat-no" title="statement not covered" >var label=this.labels[i];<span class="cstat-no" title="statement not covered" >i</span>f(label.statementStart==node.start){<span class="cstat-no" title="statement not covered" >label.statementStart=this.start;<span class="cstat-no" title="statement not covered" >l</span>abel.kind=kind;}</span>else <span class="cstat-no" title="statement not covered" >break;}</span></span></span>
<span class="cstat-no" title="statement not covered" >this.labels.push({name:maybeName,kind:kind,statementStart:this.start});<span class="cstat-no" title="statement not covered" >n</span>ode.body=this.parseStatement(true);<span class="cstat-no" title="statement not covered" >t</span>his.labels.pop();<span class="cstat-no" title="statement not covered" >n</span>ode.label=expr;<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishNode(node,"LabeledStatement");}</span>;pp.parseExpressionStatement=<span class="fstat-no" title="function not covered" >function(node,expr){<span class="cstat-no" title="statement not covered" ></span>node.expression=expr;<span class="cstat-no" title="statement not covered" >t</span>his.semicolon();<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishNode(node,"ExpressionStatement");}</span>;pp.parseBlock=<span class="fstat-no" title="function not covered" >function(allowStrict){<span class="cstat-no" title="statement not covered" ></span>var node=this.startNode(),first=true,oldStrict=undefined;<span class="cstat-no" title="statement not covered" >n</span>ode.body=[];<span class="cstat-no" title="statement not covered" >t</span>his.expect(_tokentype.types.braceL);<span class="cstat-no" title="statement not covered" >w</span>hile(!this.eat(_tokentype.types.braceR)){<span class="cstat-no" title="statement not covered" >var stmt=this.parseStatement(true);<span class="cstat-no" title="statement not covered" >n</span>ode.body.push(stmt);<span class="cstat-no" title="statement not covered" >i</span>f(first&amp;&amp;allowStrict&amp;&amp;this.isUseStrict(stmt)){<span class="cstat-no" title="statement not covered" >oldStrict=this.strict;<span class="cstat-no" title="statement not covered" >t</span>his.setStrict(this.strict=true);}</span></span></span>
<span class="cstat-no" title="statement not covered" >first=false;}</span>
<span class="cstat-no" title="statement not covered" >if(oldStrict===false)<span class="cstat-no" title="statement not covered" >this.setStrict(false);<span class="cstat-no" title="statement not covered" >r</span></span>eturn this.finishNode(node,"BlockStatement");}</span>;pp.parseFor=<span class="fstat-no" title="function not covered" >function(node,init){<span class="cstat-no" title="statement not covered" ></span>node.init=init;<span class="cstat-no" title="statement not covered" >t</span>his.expect(_tokentype.types.semi);<span class="cstat-no" title="statement not covered" >n</span>ode.test=this.type===_tokentype.types.semi?null:this.parseExpression();<span class="cstat-no" title="statement not covered" >t</span>his.expect(_tokentype.types.semi);<span class="cstat-no" title="statement not covered" >n</span>ode.update=this.type===_tokentype.types.parenR?null:this.parseExpression();<span class="cstat-no" title="statement not covered" >t</span>his.expect(_tokentype.types.parenR);<span class="cstat-no" title="statement not covered" >n</span>ode.body=this.parseStatement(false);<span class="cstat-no" title="statement not covered" >t</span>his.labels.pop();<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishNode(node,"ForStatement");}</span>;pp.parseForIn=<span class="fstat-no" title="function not covered" >function(node,init){<span class="cstat-no" title="statement not covered" ></span>var type=this.type===_tokentype.types._in?"ForInStatement":"ForOfStatement";<span class="cstat-no" title="statement not covered" >t</span>his.next();<span class="cstat-no" title="statement not covered" >n</span>ode.left=init;<span class="cstat-no" title="statement not covered" >n</span>ode.right=this.parseExpression();<span class="cstat-no" title="statement not covered" >t</span>his.expect(_tokentype.types.parenR);<span class="cstat-no" title="statement not covered" >n</span>ode.body=this.parseStatement(false);<span class="cstat-no" title="statement not covered" >t</span>his.labels.pop();<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishNode(node,type);}</span>;pp.parseVar=<span class="fstat-no" title="function not covered" >function(node,isFor,kind){<span class="cstat-no" title="statement not covered" ></span>node.declarations=[];<span class="cstat-no" title="statement not covered" >n</span>ode.kind=kind.keyword;<span class="cstat-no" title="statement not covered" >f</span>or(;;){<span class="cstat-no" title="statement not covered" >var decl=this.startNode();<span class="cstat-no" title="statement not covered" >t</span>his.parseVarId(decl);<span class="cstat-no" title="statement not covered" >i</span>f(this.eat(_tokentype.types.eq)){<span class="cstat-no" title="statement not covered" >decl.init=this.parseMaybeAssign(isFor);}</span>else <span class="cstat-no" title="statement not covered" >if(kind===_tokentype.types._const&amp;&amp;!(this.type===_tokentype.types._in||this.options.ecmaVersion&gt;=6&amp;&amp;this.isContextual("of"))){<span class="cstat-no" title="statement not covered" >this.unexpected();}</span>else <span class="cstat-no" title="statement not covered" >if(decl.id.type!="Identifier"&amp;&amp;!(isFor&amp;&amp;(this.type===_tokentype.types._in||this.isContextual("of")))){<span class="cstat-no" title="statement not covered" >this.raise(this.lastTokEnd,"Complex binding patterns require an initialization value");}</span>else{<span class="cstat-no" title="statement not covered" >decl.init=null;}</span></span></span></span></span>
<span class="cstat-no" title="statement not covered" >node.declarations.push(this.finishNode(decl,"VariableDeclarator"));<span class="cstat-no" title="statement not covered" >i</span>f(!this.eat(_tokentype.types.comma))<span class="cstat-no" title="statement not covered" >break;}</span></span>
<span class="cstat-no" title="statement not covered" >return node;}</span>;pp.parseVarId=<span class="fstat-no" title="function not covered" >function(decl){<span class="cstat-no" title="statement not covered" ></span>decl.id=this.parseBindingAtom();<span class="cstat-no" title="statement not covered" >t</span>his.checkLVal(decl.id,true);}</span>;pp.parseFunction=<span class="fstat-no" title="function not covered" >function(node,isStatement,allowExpressionBody){<span class="cstat-no" title="statement not covered" ></span>this.initFunction(node);<span class="cstat-no" title="statement not covered" >i</span>f(this.options.ecmaVersion&gt;=6)<span class="cstat-no" title="statement not covered" >node.generator=this.eat(_tokentype.types.star);<span class="cstat-no" title="statement not covered" >i</span></span>f(isStatement||this.type===_tokentype.types.name)<span class="cstat-no" title="statement not covered" >node.id=this.parseIdent();<span class="cstat-no" title="statement not covered" >t</span></span>his.parseFunctionParams(node);<span class="cstat-no" title="statement not covered" >t</span>his.parseFunctionBody(node,allowExpressionBody);<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishNode(node,isStatement?"FunctionDeclaration":"FunctionExpression");}</span>;pp.parseFunctionParams=<span class="fstat-no" title="function not covered" >function(node){<span class="cstat-no" title="statement not covered" ></span>this.expect(_tokentype.types.parenL);<span class="cstat-no" title="statement not covered" >n</span>ode.params=this.parseBindingList(_tokentype.types.parenR,false,false,true);}</span>;pp.parseClass=<span class="fstat-no" title="function not covered" >function(node,isStatement){<span class="cstat-no" title="statement not covered" ></span>this.next();<span class="cstat-no" title="statement not covered" >t</span>his.parseClassId(node,isStatement);<span class="cstat-no" title="statement not covered" >t</span>his.parseClassSuper(node);<span class="cstat-no" title="statement not covered" >v</span>ar classBody=this.startNode();<span class="cstat-no" title="statement not covered" >v</span>ar hadConstructor=false;<span class="cstat-no" title="statement not covered" >c</span>lassBody.body=[];<span class="cstat-no" title="statement not covered" >t</span>his.expect(_tokentype.types.braceL);<span class="cstat-no" title="statement not covered" >w</span>hile(!this.eat(_tokentype.types.braceR)){<span class="cstat-no" title="statement not covered" >if(this.eat(_tokentype.types.semi))<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >v</span></span>ar method=this.startNode();<span class="cstat-no" title="statement not covered" >v</span>ar isGenerator=this.eat(_tokentype.types.star);<span class="cstat-no" title="statement not covered" >v</span>ar isMaybeStatic=this.type===_tokentype.types.name&amp;&amp;this.value==="static";<span class="cstat-no" title="statement not covered" >t</span>his.parsePropertyName(method);<span class="cstat-no" title="statement not covered" >m</span>ethod["static"]=isMaybeStatic&amp;&amp;this.type!==_tokentype.types.parenL;<span class="cstat-no" title="statement not covered" >i</span>f(method["static"]){<span class="cstat-no" title="statement not covered" >if(isGenerator)<span class="cstat-no" title="statement not covered" >this.unexpected();<span class="cstat-no" title="statement not covered" >i</span></span>sGenerator=this.eat(_tokentype.types.star);<span class="cstat-no" title="statement not covered" >t</span>his.parsePropertyName(method);}</span></span></span>
<span class="cstat-no" title="statement not covered" >method.kind="method";<span class="cstat-no" title="statement not covered" >v</span>ar isGetSet=false;<span class="cstat-no" title="statement not covered" >i</span>f(!method.computed){<span class="cstat-no" title="statement not covered" >var key=method.key;<span class="cstat-no" title="statement not covered" >i</span>f(!isGenerator&amp;&amp;key.type==="Identifier"&amp;&amp;this.type!==_tokentype.types.parenL&amp;&amp;(key.name==="get"||key.name==="set")){<span class="cstat-no" title="statement not covered" >isGetSet=true;<span class="cstat-no" title="statement not covered" >m</span>ethod.kind=key.name;<span class="cstat-no" title="statement not covered" >k</span>ey=this.parsePropertyName(method);}</span></span></span>
<span class="cstat-no" title="statement not covered" >if(!method["static"]&amp;&amp;(key.type==="Identifier"&amp;&amp;key.name==="constructor"||key.type==="Literal"&amp;&amp;key.value==="constructor")){<span class="cstat-no" title="statement not covered" >if(hadConstructor)<span class="cstat-no" title="statement not covered" >this.raise(key.start,"Duplicate constructor in the same class");<span class="cstat-no" title="statement not covered" >i</span></span>f(isGetSet)<span class="cstat-no" title="statement not covered" >this.raise(key.start,"Constructor can't have get/set modifier");<span class="cstat-no" title="statement not covered" >i</span></span>f(isGenerator)<span class="cstat-no" title="statement not covered" >this.raise(key.start,"Constructor can't be a generator");<span class="cstat-no" title="statement not covered" >m</span></span>ethod.kind="constructor";<span class="cstat-no" title="statement not covered" >h</span>adConstructor=true;}</span>}</span>
<span class="cstat-no" title="statement not covered" >this.parseClassMethod(classBody,method,isGenerator);<span class="cstat-no" title="statement not covered" >i</span>f(isGetSet){<span class="cstat-no" title="statement not covered" >var paramCount=method.kind==="get"?0:1;<span class="cstat-no" title="statement not covered" >i</span>f(method.value.params.length!==paramCount){<span class="cstat-no" title="statement not covered" >var start=method.value.start;<span class="cstat-no" title="statement not covered" >i</span>f(method.kind==="get")<span class="cstat-no" title="statement not covered" >this.raise(start,"getter should have no params");e</span>lse <span class="cstat-no" title="statement not covered" >this.raise(start,"setter should have exactly one param");}</span></span>}</span>}</span>
<span class="cstat-no" title="statement not covered" >node.body=this.finishNode(classBody,"ClassBody");<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishNode(node,isStatement?"ClassDeclaration":"ClassExpression");}</span>;pp.parseClassMethod=<span class="fstat-no" title="function not covered" >function(classBody,method,isGenerator){<span class="cstat-no" title="statement not covered" ></span>method.value=this.parseMethod(isGenerator);<span class="cstat-no" title="statement not covered" >c</span>lassBody.body.push(this.finishNode(method,"MethodDefinition"));}</span>;pp.parseClassId=<span class="fstat-no" title="function not covered" >function(node,isStatement){<span class="cstat-no" title="statement not covered" ></span>node.id=this.type===_tokentype.types.name?this.parseIdent():isStatement?this.unexpected():null;}</span>;pp.parseClassSuper=<span class="fstat-no" title="function not covered" >function(node){<span class="cstat-no" title="statement not covered" ></span>node.superClass=this.eat(_tokentype.types._extends)?this.parseExprSubscripts():null;}</span>;pp.parseExport=<span class="fstat-no" title="function not covered" >function(node){<span class="cstat-no" title="statement not covered" ></span>this.next();<span class="cstat-no" title="statement not covered" >i</span>f(this.eat(_tokentype.types.star)){<span class="cstat-no" title="statement not covered" >this.expectContextual("from");<span class="cstat-no" title="statement not covered" >n</span>ode.source=this.type===_tokentype.types.string?this.parseExprAtom():this.unexpected();<span class="cstat-no" title="statement not covered" >t</span>his.semicolon();<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishNode(node,"ExportAllDeclaration");}</span></span>
<span class="cstat-no" title="statement not covered" >if(this.eat(_tokentype.types._default)){<span class="cstat-no" title="statement not covered" >var expr=this.parseMaybeAssign();<span class="cstat-no" title="statement not covered" >v</span>ar needsSemi=true;<span class="cstat-no" title="statement not covered" >i</span>f(expr.type=="FunctionExpression"||expr.type=="ClassExpression"){<span class="cstat-no" title="statement not covered" >needsSemi=false;<span class="cstat-no" title="statement not covered" >i</span>f(expr.id){<span class="cstat-no" title="statement not covered" >expr.type=expr.type=="FunctionExpression"?"FunctionDeclaration":"ClassDeclaration";}</span>}</span></span></span>
<span class="cstat-no" title="statement not covered" >node.declaration=expr;<span class="cstat-no" title="statement not covered" >i</span>f(needsSemi)<span class="cstat-no" title="statement not covered" >this.semicolon();<span class="cstat-no" title="statement not covered" >r</span></span>eturn this.finishNode(node,"ExportDefaultDeclaration");}</span>
<span class="cstat-no" title="statement not covered" >if(this.shouldParseExportStatement()){<span class="cstat-no" title="statement not covered" >node.declaration=this.parseStatement(true);<span class="cstat-no" title="statement not covered" >n</span>ode.specifiers=[];<span class="cstat-no" title="statement not covered" >n</span>ode.source=null;}</span>else{<span class="cstat-no" title="statement not covered" >node.declaration=null;<span class="cstat-no" title="statement not covered" >n</span>ode.specifiers=this.parseExportSpecifiers();<span class="cstat-no" title="statement not covered" >i</span>f(this.eatContextual("from")){<span class="cstat-no" title="statement not covered" >node.source=this.type===_tokentype.types.string?this.parseExprAtom():this.unexpected();}</span>else{<span class="cstat-no" title="statement not covered" >for(var i=0;i&lt;node.specifiers.length;i++){<span class="cstat-no" title="statement not covered" >if(this.keywords.test(node.specifiers[i].local.name)||this.reservedWords.test(node.specifiers[i].local.name)){<span class="cstat-no" title="statement not covered" >this.unexpected(node.specifiers[i].local.start);}</span>}</span></span></span></span>
<span class="cstat-no" title="statement not covered" >node.source=null;}</span>
<span class="cstat-no" title="statement not covered" >this.semicolon();}</span>
<span class="cstat-no" title="statement not covered" >return this.finishNode(node,"ExportNamedDeclaration");}</span>;pp.shouldParseExportStatement=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>return this.type.keyword;}</span>;pp.parseExportSpecifiers=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>var nodes=[],first=true;<span class="cstat-no" title="statement not covered" >t</span>his.expect(_tokentype.types.braceL);<span class="cstat-no" title="statement not covered" >w</span>hile(!this.eat(_tokentype.types.braceR)){<span class="cstat-no" title="statement not covered" >if(!first){<span class="cstat-no" title="statement not covered" >this.expect(_tokentype.types.comma);<span class="cstat-no" title="statement not covered" >i</span>f(this.afterTrailingComma(_tokentype.types.braceR))<span class="cstat-no" title="statement not covered" >break;}</span></span>else <span class="cstat-no" title="statement not covered" >first=false;<span class="cstat-no" title="statement not covered" >v</span></span>ar node=this.startNode();<span class="cstat-no" title="statement not covered" >n</span>ode.local=this.parseIdent(this.type===_tokentype.types._default);<span class="cstat-no" title="statement not covered" >n</span>ode.exported=this.eatContextual("as")?this.parseIdent(true):node.local;<span class="cstat-no" title="statement not covered" >n</span>odes.push(this.finishNode(node,"ExportSpecifier"));}</span></span>
<span class="cstat-no" title="statement not covered" >return nodes;}</span>;pp.parseImport=<span class="fstat-no" title="function not covered" >function(node){<span class="cstat-no" title="statement not covered" ></span>this.next();<span class="cstat-no" title="statement not covered" >i</span>f(this.type===_tokentype.types.string){<span class="cstat-no" title="statement not covered" >node.specifiers=empty;<span class="cstat-no" title="statement not covered" >n</span>ode.source=this.parseExprAtom();}</span>else{<span class="cstat-no" title="statement not covered" >node.specifiers=this.parseImportSpecifiers();<span class="cstat-no" title="statement not covered" >t</span>his.expectContextual("from");<span class="cstat-no" title="statement not covered" >n</span>ode.source=this.type===_tokentype.types.string?this.parseExprAtom():this.unexpected();}</span></span>
<span class="cstat-no" title="statement not covered" >this.semicolon();<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishNode(node,"ImportDeclaration");}</span>;pp.parseImportSpecifiers=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>var nodes=[],first=true;<span class="cstat-no" title="statement not covered" >i</span>f(this.type===_tokentype.types.name){<span class="cstat-no" title="statement not covered" >var node=this.startNode();<span class="cstat-no" title="statement not covered" >n</span>ode.local=this.parseIdent();<span class="cstat-no" title="statement not covered" >t</span>his.checkLVal(node.local,true);<span class="cstat-no" title="statement not covered" >n</span>odes.push(this.finishNode(node,"ImportDefaultSpecifier"));<span class="cstat-no" title="statement not covered" >i</span>f(!this.eat(_tokentype.types.comma))<span class="cstat-no" title="statement not covered" >return nodes;}</span></span></span>
<span class="cstat-no" title="statement not covered" >if(this.type===_tokentype.types.star){<span class="cstat-no" title="statement not covered" >var node=this.startNode();<span class="cstat-no" title="statement not covered" >t</span>his.next();<span class="cstat-no" title="statement not covered" >t</span>his.expectContextual("as");<span class="cstat-no" title="statement not covered" >n</span>ode.local=this.parseIdent();<span class="cstat-no" title="statement not covered" >t</span>his.checkLVal(node.local,true);<span class="cstat-no" title="statement not covered" >n</span>odes.push(this.finishNode(node,"ImportNamespaceSpecifier"));<span class="cstat-no" title="statement not covered" >r</span>eturn nodes;}</span></span>
<span class="cstat-no" title="statement not covered" >this.expect(_tokentype.types.braceL);<span class="cstat-no" title="statement not covered" >w</span>hile(!this.eat(_tokentype.types.braceR)){<span class="cstat-no" title="statement not covered" >if(!first){<span class="cstat-no" title="statement not covered" >this.expect(_tokentype.types.comma);<span class="cstat-no" title="statement not covered" >i</span>f(this.afterTrailingComma(_tokentype.types.braceR))<span class="cstat-no" title="statement not covered" >break;}</span></span>else <span class="cstat-no" title="statement not covered" >first=false;<span class="cstat-no" title="statement not covered" >v</span></span>ar node=this.startNode();<span class="cstat-no" title="statement not covered" >n</span>ode.imported=this.parseIdent(true);<span class="cstat-no" title="statement not covered" >n</span>ode.local=this.eatContextual("as")?this.parseIdent():node.imported;<span class="cstat-no" title="statement not covered" >t</span>his.checkLVal(node.local,true);<span class="cstat-no" title="statement not covered" >n</span>odes.push(this.finishNode(node,"ImportSpecifier"));}</span></span>
<span class="cstat-no" title="statement not covered" >return nodes;}</span>;},{"./state":10,"./tokentype":14,"./whitespace":16}],12:[function(_dereq_,module,exports){"use strict";exports.__esModule=true;function _classCallCheck(instance,Constructor){<span class="missing-if-branch" title="if path not taken" >I</span>if(!(instance instanceof Constructor)){<span class="cstat-no" title="statement not covered" >throw new TypeError("Cannot call a class as a function");}</span>}
var _state=_dereq_("./state");var _tokentype=_dereq_("./tokentype");var _whitespace=_dereq_("./whitespace");var TokContext=function TokContext(token,isExpr,preserveSpace,override){_classCallCheck(this,TokContext);this.token=token;this.isExpr=!!isExpr;this.preserveSpace=!!preserveSpace;this.override=override;};exports.TokContext=TokContext;var types={b_stat:new TokContext("{",false),b_expr:new TokContext("{",true),b_tmpl:new TokContext("${",true),p_stat:new TokContext("(",false),p_expr:new TokContext("(",true),q_tmpl:new TokContext("`",true,true,<span class="fstat-no" title="function not covered" >function(p){<span class="cstat-no" title="statement not covered" ></span>return p.readTmplToken();}</span>),f_expr:new TokContext("function",true)};exports.types=types;var pp=_state.Parser.prototype;pp.initialContext=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>return[types.b_stat];}</span>;pp.braceIsBlock=<span class="fstat-no" title="function not covered" >function(prevType){<span class="cstat-no" title="statement not covered" ></span>if(prevType===_tokentype.types.colon){<span class="cstat-no" title="statement not covered" >var _parent=this.curContext();<span class="cstat-no" title="statement not covered" >i</span>f(_parent===types.b_stat||_parent===types.b_expr)<span class="cstat-no" title="statement not covered" >return!_parent.isExpr;}</span></span></span>
<span class="cstat-no" title="statement not covered" >if(prevType===_tokentype.types._return)<span class="cstat-no" title="statement not covered" >return _whitespace.lineBreak.test(this.input.slice(this.lastTokEnd,this.start));<span class="cstat-no" title="statement not covered" >i</span></span>f(prevType===_tokentype.types._else||prevType===_tokentype.types.semi||prevType===_tokentype.types.eof||prevType===_tokentype.types.parenR)<span class="cstat-no" title="statement not covered" >return true;<span class="cstat-no" title="statement not covered" >i</span></span>f(prevType==_tokentype.types.braceL)<span class="cstat-no" title="statement not covered" >return this.curContext()===types.b_stat;<span class="cstat-no" title="statement not covered" >r</span></span>eturn!this.exprAllowed;}</span>;pp.updateContext=<span class="fstat-no" title="function not covered" >function(prevType){<span class="cstat-no" title="statement not covered" ></span>var update=undefined,type=this.type;<span class="cstat-no" title="statement not covered" >i</span>f(type.keyword&amp;&amp;prevType==_tokentype.types.dot)<span class="cstat-no" title="statement not covered" >this.exprAllowed=false;e</span>lse <span class="cstat-no" title="statement not covered" >if(update=type.updateContext)<span class="cstat-no" title="statement not covered" >update.call(this,prevType);e</span>lse <span class="cstat-no" title="statement not covered" >this.exprAllowed=type.beforeExpr;}</span></span></span>;_tokentype.types.parenR.updateContext=_tokentype.types.braceR.updateContext=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>if(this.context.length==1){<span class="cstat-no" title="statement not covered" >this.exprAllowed=true;<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span></span>
<span class="cstat-no" title="statement not covered" >var out=this.context.pop();<span class="cstat-no" title="statement not covered" >i</span>f(out===types.b_stat&amp;&amp;this.curContext()===types.f_expr){<span class="cstat-no" title="statement not covered" >this.context.pop();<span class="cstat-no" title="statement not covered" >t</span>his.exprAllowed=false;}</span>else <span class="cstat-no" title="statement not covered" >if(out===types.b_tmpl){<span class="cstat-no" title="statement not covered" >this.exprAllowed=true;}</span>else{<span class="cstat-no" title="statement not covered" >this.exprAllowed=!out.isExpr;}</span>}</span></span>;_tokentype.types.braceL.updateContext=<span class="fstat-no" title="function not covered" >function(prevType){<span class="cstat-no" title="statement not covered" ></span>this.context.push(this.braceIsBlock(prevType)?types.b_stat:types.b_expr);<span class="cstat-no" title="statement not covered" >t</span>his.exprAllowed=true;}</span>;_tokentype.types.dollarBraceL.updateContext=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>this.context.push(types.b_tmpl);<span class="cstat-no" title="statement not covered" >t</span>his.exprAllowed=true;}</span>;_tokentype.types.parenL.updateContext=<span class="fstat-no" title="function not covered" >function(prevType){<span class="cstat-no" title="statement not covered" ></span>var statementParens=prevType===_tokentype.types._if||prevType===_tokentype.types._for||prevType===_tokentype.types._with||prevType===_tokentype.types._while;<span class="cstat-no" title="statement not covered" >t</span>his.context.push(statementParens?types.p_stat:types.p_expr);<span class="cstat-no" title="statement not covered" >t</span>his.exprAllowed=true;}</span>;_tokentype.types.incDec.updateContext=<span class="fstat-no" title="function not covered" >function(){</span>};_tokentype.types._function.updateContext=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>if(this.curContext()!==types.b_stat)<span class="cstat-no" title="statement not covered" >this.context.push(types.f_expr);<span class="cstat-no" title="statement not covered" >t</span></span>his.exprAllowed=false;}</span>;_tokentype.types.backQuote.updateContext=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>if(this.curContext()===types.q_tmpl)<span class="cstat-no" title="statement not covered" >this.context.pop();e</span>lse <span class="cstat-no" title="statement not covered" >this.context.push(types.q_tmpl);<span class="cstat-no" title="statement not covered" >t</span></span>his.exprAllowed=false;}</span>;},{"./state":10,"./tokentype":14,"./whitespace":16}],13:[function(_dereq_,module,exports){"use strict";exports.__esModule=true;<span class="fstat-no" title="function not covered" >function _classCallCheck(instance,Constructor){<span class="cstat-no" title="statement not covered" ></span>if(!(instance instanceof Constructor)){<span class="cstat-no" title="statement not covered" >throw new TypeError("Cannot call a class as a function");}</span>}</span>
var _identifier=_dereq_("./identifier");var _tokentype=_dereq_("./tokentype");var _state=_dereq_("./state");var _locutil=_dereq_("./locutil");var _whitespace=_dereq_("./whitespace");var Token=<span class="fstat-no" title="function not covered" >function Token(p){<span class="cstat-no" title="statement not covered" ></span>_classCallCheck(this,Token);<span class="cstat-no" title="statement not covered" >t</span>his.type=p.type;<span class="cstat-no" title="statement not covered" >t</span>his.value=p.value;<span class="cstat-no" title="statement not covered" >t</span>his.start=p.start;<span class="cstat-no" title="statement not covered" >t</span>his.end=p.end;<span class="cstat-no" title="statement not covered" >i</span>f(p.options.locations)<span class="cstat-no" title="statement not covered" >this.loc=new _locutil.SourceLocation(p,p.startLoc,p.endLoc);<span class="cstat-no" title="statement not covered" >i</span></span>f(p.options.ranges)<span class="cstat-no" title="statement not covered" >this.range=[p.start,p.end];}</span></span>;exports.Token=Token;var pp=_state.Parser.prototype;var isRhino=typeof Packages=="object"&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >Object.prototype.toString.call(Packages)=="[object JavaPackage]";</span>pp.next=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>if(this.options.onToken)<span class="cstat-no" title="statement not covered" >this.options.onToken(new Token(this));<span class="cstat-no" title="statement not covered" >t</span></span>his.lastTokEnd=this.end;<span class="cstat-no" title="statement not covered" >t</span>his.lastTokStart=this.start;<span class="cstat-no" title="statement not covered" >t</span>his.lastTokEndLoc=this.endLoc;<span class="cstat-no" title="statement not covered" >t</span>his.lastTokStartLoc=this.startLoc;<span class="cstat-no" title="statement not covered" >t</span>his.nextToken();}</span>;pp.getToken=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>this.next();<span class="cstat-no" title="statement not covered" >r</span>eturn new Token(this);}</span>;<span class="missing-if-branch" title="else path not taken" >E</span>if(typeof Symbol!=="undefined")pp[Symbol.iterator]=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>var self=this;<span class="cstat-no" title="statement not covered" >r</span>eturn{next:<span class="fstat-no" title="function not covered" >function next(){<span class="cstat-no" title="statement not covered" ></span>var token=self.getToken();<span class="cstat-no" title="statement not covered" >r</span>eturn{done:token.type===_tokentype.types.eof,value:token};}</span>};}</span>;pp.setStrict=<span class="fstat-no" title="function not covered" >function(strict){<span class="cstat-no" title="statement not covered" ></span>this.strict=strict;<span class="cstat-no" title="statement not covered" >i</span>f(this.type!==_tokentype.types.num&amp;&amp;this.type!==_tokentype.types.string)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span></span>his.pos=this.start;<span class="cstat-no" title="statement not covered" >i</span>f(this.options.locations){<span class="cstat-no" title="statement not covered" >while(this.pos&lt;this.lineStart){<span class="cstat-no" title="statement not covered" >this.lineStart=this.input.lastIndexOf("\n",this.lineStart-2)+1;<span class="cstat-no" title="statement not covered" >-</span>-this.curLine;}</span>}</span></span>
<span class="cstat-no" title="statement not covered" >this.nextToken();}</span>;pp.curContext=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>return this.context[this.context.length-1];}</span>;pp.nextToken=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>var curContext=this.curContext();<span class="cstat-no" title="statement not covered" >i</span>f(!curContext||!curContext.preserveSpace)<span class="cstat-no" title="statement not covered" >this.skipSpace();<span class="cstat-no" title="statement not covered" >t</span></span>his.start=this.pos;<span class="cstat-no" title="statement not covered" >i</span>f(this.options.locations)<span class="cstat-no" title="statement not covered" >this.startLoc=this.curPosition();<span class="cstat-no" title="statement not covered" >i</span></span>f(this.pos&gt;=this.input.length)<span class="cstat-no" title="statement not covered" >return this.finishToken(_tokentype.types.eof);<span class="cstat-no" title="statement not covered" >i</span></span>f(curContext.override)<span class="cstat-no" title="statement not covered" >return curContext.override(this);e</span>lse <span class="cstat-no" title="statement not covered" >this.readToken(this.fullCharCodeAtPos());}</span></span>;pp.readToken=<span class="fstat-no" title="function not covered" >function(code){<span class="cstat-no" title="statement not covered" ></span>if(_identifier.isIdentifierStart(code,this.options.ecmaVersion&gt;=6)||code===92)<span class="cstat-no" title="statement not covered" >return this.readWord();<span class="cstat-no" title="statement not covered" >r</span></span>eturn this.getTokenFromCode(code);}</span>;pp.fullCharCodeAtPos=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>var code=this.input.charCodeAt(this.pos);<span class="cstat-no" title="statement not covered" >i</span>f(code&lt;=0xd7ff||code&gt;=0xe000)<span class="cstat-no" title="statement not covered" >return code;<span class="cstat-no" title="statement not covered" >v</span></span>ar next=this.input.charCodeAt(this.pos+1);<span class="cstat-no" title="statement not covered" >r</span>eturn(code&lt;&lt;10)+next-0x35fdc00;}</span>;pp.skipBlockComment=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>var startLoc=this.options.onComment&amp;&amp;this.curPosition();<span class="cstat-no" title="statement not covered" >v</span>ar start=this.pos,end=this.input.indexOf("*/",this.pos+=2);<span class="cstat-no" title="statement not covered" >i</span>f(end===-1)<span class="cstat-no" title="statement not covered" >this.raise(this.pos-2,"Unterminated comment");<span class="cstat-no" title="statement not covered" >t</span></span>his.pos=end+2;<span class="cstat-no" title="statement not covered" >i</span>f(this.options.locations){<span class="cstat-no" title="statement not covered" >_whitespace.lineBreakG.lastIndex=start;<span class="cstat-no" title="statement not covered" >v</span>ar match=undefined;<span class="cstat-no" title="statement not covered" >w</span>hile((match=_whitespace.lineBreakG.exec(this.input))&amp;&amp;match.index&lt;this.pos){<span class="cstat-no" title="statement not covered" >++this.curLine;<span class="cstat-no" title="statement not covered" >t</span>his.lineStart=match.index+match[0].length;}</span>}</span></span>
<span class="cstat-no" title="statement not covered" >if(this.options.onComment)<span class="cstat-no" title="statement not covered" >this.options.onComment(true,this.input.slice(start+2,end),start,this.pos,startLoc,this.curPosition());}</span></span>;pp.skipLineComment=<span class="fstat-no" title="function not covered" >function(startSkip){<span class="cstat-no" title="statement not covered" ></span>var start=this.pos;<span class="cstat-no" title="statement not covered" >v</span>ar startLoc=this.options.onComment&amp;&amp;this.curPosition();<span class="cstat-no" title="statement not covered" >v</span>ar ch=this.input.charCodeAt(this.pos+=startSkip);<span class="cstat-no" title="statement not covered" >w</span>hile(this.pos&lt;this.input.length&amp;&amp;ch!==10&amp;&amp;ch!==13&amp;&amp;ch!==8232&amp;&amp;ch!==8233){<span class="cstat-no" title="statement not covered" >++this.pos;<span class="cstat-no" title="statement not covered" >c</span>h=this.input.charCodeAt(this.pos);}</span></span>
<span class="cstat-no" title="statement not covered" >if(this.options.onComment)<span class="cstat-no" title="statement not covered" >this.options.onComment(false,this.input.slice(start+startSkip,this.pos),start,this.pos,startLoc,this.curPosition());}</span></span>;pp.skipSpace=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>loop:<span class="cstat-no" title="statement not covered" >while(this.pos&lt;this.input.length){<span class="cstat-no" title="statement not covered" >var ch=this.input.charCodeAt(this.pos);<span class="cstat-no" title="statement not covered" >s</span>witch(ch){case 32:case 160:<span class="cstat-no" title="statement not covered" >++this.pos;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase 13:<span class="cstat-no" title="statement not covered" >if(this.input.charCodeAt(this.pos+1)===10){<span class="cstat-no" title="statement not covered" >++this.pos;}</span></span></span></span></span>
case 10:case 8232:case 8233:<span class="cstat-no" title="statement not covered" >++this.pos;<span class="cstat-no" title="statement not covered" >i</span>f(this.options.locations){<span class="cstat-no" title="statement not covered" >++this.curLine;<span class="cstat-no" title="statement not covered" >t</span>his.lineStart=this.pos;}</span></span>
<span class="cstat-no" title="statement not covered" >break;c</span>ase 47:<span class="cstat-no" title="statement not covered" >switch(this.input.charCodeAt(this.pos+1)){case 42:<span class="cstat-no" title="statement not covered" >this.skipBlockComment();<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase 47:<span class="cstat-no" title="statement not covered" >this.skipLineComment(2);<span class="cstat-no" title="statement not covered" >b</span>reak;d</span>efault:<span class="cstat-no" title="statement not covered" >break loop;}</span></span>
<span class="cstat-no" title="statement not covered" >break;d</span>efault:<span class="cstat-no" title="statement not covered" >if(ch&gt;8&amp;&amp;ch&lt;14||ch&gt;=5760&amp;&amp;_whitespace.nonASCIIwhitespace.test(String.fromCharCode(ch))){<span class="cstat-no" title="statement not covered" >++this.pos;}</span>else{<span class="cstat-no" title="statement not covered" >break loop;}</span>}</span>}};pp.finishToken=<span class="fstat-no" title="function not covered" >function(type,val){<span class="cstat-no" title="statement not covered" ></span>this.end=this.pos;<span class="cstat-no" title="statement not covered" >i</span>f(this.options.locations)<span class="cstat-no" title="statement not covered" >this.endLoc=this.curPosition();<span class="cstat-no" title="statement not covered" >v</span></span>ar prevType=this.type;<span class="cstat-no" title="statement not covered" >t</span>his.type=type;<span class="cstat-no" title="statement not covered" >t</span>his.value=val;<span class="cstat-no" title="statement not covered" >t</span>his.updateContext(prevType);}</span>;pp.readToken_dot=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>var next=this.input.charCodeAt(this.pos+1);<span class="cstat-no" title="statement not covered" >i</span>f(next&gt;=48&amp;&amp;next&lt;=57)<span class="cstat-no" title="statement not covered" >return this.readNumber(true);<span class="cstat-no" title="statement not covered" >v</span></span>ar next2=this.input.charCodeAt(this.pos+2);<span class="cstat-no" title="statement not covered" >i</span>f(this.options.ecmaVersion&gt;=6&amp;&amp;next===46&amp;&amp;next2===46){<span class="cstat-no" title="statement not covered" >this.pos+=3;<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishToken(_tokentype.types.ellipsis);}</span>else{<span class="cstat-no" title="statement not covered" >++this.pos;<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishToken(_tokentype.types.dot);}</span>}</span>;pp.readToken_slash=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>var next=this.input.charCodeAt(this.pos+1);<span class="cstat-no" title="statement not covered" >i</span>f(this.exprAllowed){<span class="cstat-no" title="statement not covered" >++this.pos;<span class="cstat-no" title="statement not covered" >r</span>eturn this.readRegexp();}</span></span>
<span class="cstat-no" title="statement not covered" >if(next===61)<span class="cstat-no" title="statement not covered" >return this.finishOp(_tokentype.types.assign,2);<span class="cstat-no" title="statement not covered" >r</span></span>eturn this.finishOp(_tokentype.types.slash,1);}</span>;pp.readToken_mult_modulo=<span class="fstat-no" title="function not covered" >function(code){<span class="cstat-no" title="statement not covered" ></span>var next=this.input.charCodeAt(this.pos+1);<span class="cstat-no" title="statement not covered" >i</span>f(next===61)<span class="cstat-no" title="statement not covered" >return this.finishOp(_tokentype.types.assign,2);<span class="cstat-no" title="statement not covered" >r</span></span>eturn this.finishOp(code===42?_tokentype.types.star:_tokentype.types.modulo,1);}</span>;pp.readToken_pipe_amp=<span class="fstat-no" title="function not covered" >function(code){<span class="cstat-no" title="statement not covered" ></span>var next=this.input.charCodeAt(this.pos+1);<span class="cstat-no" title="statement not covered" >i</span>f(next===code)<span class="cstat-no" title="statement not covered" >return this.finishOp(code===124?_tokentype.types.logicalOR:_tokentype.types.logicalAND,2);<span class="cstat-no" title="statement not covered" >i</span></span>f(next===61)<span class="cstat-no" title="statement not covered" >return this.finishOp(_tokentype.types.assign,2);<span class="cstat-no" title="statement not covered" >r</span></span>eturn this.finishOp(code===124?_tokentype.types.bitwiseOR:_tokentype.types.bitwiseAND,1);}</span>;pp.readToken_caret=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>var next=this.input.charCodeAt(this.pos+1);<span class="cstat-no" title="statement not covered" >i</span>f(next===61)<span class="cstat-no" title="statement not covered" >return this.finishOp(_tokentype.types.assign,2);<span class="cstat-no" title="statement not covered" >r</span></span>eturn this.finishOp(_tokentype.types.bitwiseXOR,1);}</span>;pp.readToken_plus_min=<span class="fstat-no" title="function not covered" >function(code){<span class="cstat-no" title="statement not covered" ></span>var next=this.input.charCodeAt(this.pos+1);<span class="cstat-no" title="statement not covered" >i</span>f(next===code){<span class="cstat-no" title="statement not covered" >if(next==45&amp;&amp;this.input.charCodeAt(this.pos+2)==62&amp;&amp;_whitespace.lineBreak.test(this.input.slice(this.lastTokEnd,this.pos))){<span class="cstat-no" title="statement not covered" >this.skipLineComment(3);<span class="cstat-no" title="statement not covered" >t</span>his.skipSpace();<span class="cstat-no" title="statement not covered" >r</span>eturn this.nextToken();}</span></span></span>
<span class="cstat-no" title="statement not covered" >return this.finishOp(_tokentype.types.incDec,2);}</span>
<span class="cstat-no" title="statement not covered" >if(next===61)<span class="cstat-no" title="statement not covered" >return this.finishOp(_tokentype.types.assign,2);<span class="cstat-no" title="statement not covered" >r</span></span>eturn this.finishOp(_tokentype.types.plusMin,1);}</span>;pp.readToken_lt_gt=<span class="fstat-no" title="function not covered" >function(code){<span class="cstat-no" title="statement not covered" ></span>var next=this.input.charCodeAt(this.pos+1);<span class="cstat-no" title="statement not covered" >v</span>ar size=1;<span class="cstat-no" title="statement not covered" >i</span>f(next===code){<span class="cstat-no" title="statement not covered" >size=code===62&amp;&amp;this.input.charCodeAt(this.pos+2)===62?3:2;<span class="cstat-no" title="statement not covered" >i</span>f(this.input.charCodeAt(this.pos+size)===61)<span class="cstat-no" title="statement not covered" >return this.finishOp(_tokentype.types.assign,size+1);<span class="cstat-no" title="statement not covered" >r</span></span>eturn this.finishOp(_tokentype.types.bitShift,size);}</span></span>
<span class="cstat-no" title="statement not covered" >if(next==33&amp;&amp;code==60&amp;&amp;this.input.charCodeAt(this.pos+2)==45&amp;&amp;this.input.charCodeAt(this.pos+3)==45){<span class="cstat-no" title="statement not covered" >if(this.inModule)<span class="cstat-no" title="statement not covered" >this.unexpected();<span class="cstat-no" title="statement not covered" >t</span></span>his.skipLineComment(4);<span class="cstat-no" title="statement not covered" >t</span>his.skipSpace();<span class="cstat-no" title="statement not covered" >r</span>eturn this.nextToken();}</span></span>
<span class="cstat-no" title="statement not covered" >if(next===61)<span class="cstat-no" title="statement not covered" >size=this.input.charCodeAt(this.pos+2)===61?3:2;<span class="cstat-no" title="statement not covered" >r</span></span>eturn this.finishOp(_tokentype.types.relational,size);}</span>;pp.readToken_eq_excl=<span class="fstat-no" title="function not covered" >function(code){<span class="cstat-no" title="statement not covered" ></span>var next=this.input.charCodeAt(this.pos+1);<span class="cstat-no" title="statement not covered" >i</span>f(next===61)<span class="cstat-no" title="statement not covered" >return this.finishOp(_tokentype.types.equality,this.input.charCodeAt(this.pos+2)===61?3:2);<span class="cstat-no" title="statement not covered" >i</span></span>f(code===61&amp;&amp;next===62&amp;&amp;this.options.ecmaVersion&gt;=6){<span class="cstat-no" title="statement not covered" >this.pos+=2;<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishToken(_tokentype.types.arrow);}</span></span>
<span class="cstat-no" title="statement not covered" >return this.finishOp(code===61?_tokentype.types.eq:_tokentype.types.prefix,1);}</span>;pp.getTokenFromCode=<span class="fstat-no" title="function not covered" >function(code){<span class="cstat-no" title="statement not covered" ></span>switch(code){case 46:<span class="cstat-no" title="statement not covered" >return this.readToken_dot();c</span>ase 40:<span class="cstat-no" title="statement not covered" >++this.pos;<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishToken(_tokentype.types.parenL);c</span>ase 41:<span class="cstat-no" title="statement not covered" >++this.pos;<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishToken(_tokentype.types.parenR);c</span>ase 59:<span class="cstat-no" title="statement not covered" >++this.pos;<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishToken(_tokentype.types.semi);c</span>ase 44:<span class="cstat-no" title="statement not covered" >++this.pos;<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishToken(_tokentype.types.comma);c</span>ase 91:<span class="cstat-no" title="statement not covered" >++this.pos;<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishToken(_tokentype.types.bracketL);c</span>ase 93:<span class="cstat-no" title="statement not covered" >++this.pos;<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishToken(_tokentype.types.bracketR);c</span>ase 123:<span class="cstat-no" title="statement not covered" >++this.pos;<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishToken(_tokentype.types.braceL);c</span>ase 125:<span class="cstat-no" title="statement not covered" >++this.pos;<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishToken(_tokentype.types.braceR);c</span>ase 58:<span class="cstat-no" title="statement not covered" >++this.pos;<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishToken(_tokentype.types.colon);c</span>ase 63:<span class="cstat-no" title="statement not covered" >++this.pos;<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishToken(_tokentype.types.question);c</span>ase 96:<span class="cstat-no" title="statement not covered" >if(this.options.ecmaVersion&lt;6)<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >+</span></span>+this.pos;<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishToken(_tokentype.types.backQuote);c</span>ase 48:<span class="cstat-no" title="statement not covered" >var next=this.input.charCodeAt(this.pos+1);<span class="cstat-no" title="statement not covered" >i</span>f(next===120||next===88)<span class="cstat-no" title="statement not covered" >return this.readRadixNumber(16);<span class="cstat-no" title="statement not covered" >i</span></span>f(this.options.ecmaVersion&gt;=6){<span class="cstat-no" title="statement not covered" >if(next===111||next===79)<span class="cstat-no" title="statement not covered" >return this.readRadixNumber(8);<span class="cstat-no" title="statement not covered" >i</span></span>f(next===98||next===66)<span class="cstat-no" title="statement not covered" >return this.readRadixNumber(2);}</span></span></span></span>
case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:<span class="cstat-no" title="statement not covered" >return this.readNumber(false);c</span>ase 34:case 39:<span class="cstat-no" title="statement not covered" >return this.readString(code);c</span>ase 47:<span class="cstat-no" title="statement not covered" >return this.readToken_slash();c</span>ase 37:case 42:<span class="cstat-no" title="statement not covered" >return this.readToken_mult_modulo(code);c</span>ase 124:case 38:<span class="cstat-no" title="statement not covered" >return this.readToken_pipe_amp(code);c</span>ase 94:<span class="cstat-no" title="statement not covered" >return this.readToken_caret();c</span>ase 43:case 45:<span class="cstat-no" title="statement not covered" >return this.readToken_plus_min(code);c</span>ase 60:case 62:<span class="cstat-no" title="statement not covered" >return this.readToken_lt_gt(code);c</span>ase 61:case 33:<span class="cstat-no" title="statement not covered" >return this.readToken_eq_excl(code);c</span>ase 126:<span class="cstat-no" title="statement not covered" >return this.finishOp(_tokentype.types.prefix,1);}</span>
<span class="cstat-no" title="statement not covered" >this.raise(this.pos,"Unexpected character '"+codePointToString(code)+"'");}</span>;pp.finishOp=<span class="fstat-no" title="function not covered" >function(type,size){<span class="cstat-no" title="statement not covered" ></span>var str=this.input.slice(this.pos,this.pos+size);<span class="cstat-no" title="statement not covered" >t</span>his.pos+=size;<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishToken(type,str);}</span>;function tryCreateRegexp(src,flags,throwErrorAt,parser){try{return new RegExp(src,flags);}catch(e){<span class="cstat-no" title="statement not covered" >if(throwErrorAt!==undefined){<span class="cstat-no" title="statement not covered" >if(e instanceof SyntaxError)<span class="cstat-no" title="statement not covered" >parser.raise(throwErrorAt,"Error parsing regular expression: "+e.message);<span class="cstat-no" title="statement not covered" >t</span></span>hrow e;}</span>}</span>}
var regexpUnicodeSupport=!!tryCreateRegexp("","u");pp.readRegexp=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>var _this=this;<span class="cstat-no" title="statement not covered" >v</span>ar escaped=undefined,inClass=undefined,start=this.pos;<span class="cstat-no" title="statement not covered" >f</span>or(;;){<span class="cstat-no" title="statement not covered" >if(this.pos&gt;=this.input.length)<span class="cstat-no" title="statement not covered" >this.raise(start,"Unterminated regular expression");<span class="cstat-no" title="statement not covered" >v</span></span>ar ch=this.input.charAt(this.pos);<span class="cstat-no" title="statement not covered" >i</span>f(_whitespace.lineBreak.test(ch))<span class="cstat-no" title="statement not covered" >this.raise(start,"Unterminated regular expression");<span class="cstat-no" title="statement not covered" >i</span></span>f(!escaped){<span class="cstat-no" title="statement not covered" >if(ch==="[")<span class="cstat-no" title="statement not covered" >inClass=true;e</span>lse <span class="cstat-no" title="statement not covered" >if(ch==="]"&amp;&amp;inClass)<span class="cstat-no" title="statement not covered" >inClass=false;e</span>lse <span class="cstat-no" title="statement not covered" >if(ch==="/"&amp;&amp;!inClass)<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >e</span></span></span></span>scaped=ch==="\\";}</span>else <span class="cstat-no" title="statement not covered" >escaped=false;<span class="cstat-no" title="statement not covered" >+</span></span>+this.pos;}</span></span>
<span class="cstat-no" title="statement not covered" >var content=this.input.slice(start,this.pos);<span class="cstat-no" title="statement not covered" >+</span>+this.pos;<span class="cstat-no" title="statement not covered" >v</span>ar mods=this.readWord1();<span class="cstat-no" title="statement not covered" >v</span>ar tmp=content;<span class="cstat-no" title="statement not covered" >i</span>f(mods){<span class="cstat-no" title="statement not covered" >var validFlags=/^[gmsiy]*$/;<span class="cstat-no" title="statement not covered" >i</span>f(this.options.ecmaVersion&gt;=6)<span class="cstat-no" title="statement not covered" >validFlags=/^[gmsiyu]*$/;<span class="cstat-no" title="statement not covered" >i</span></span>f(!validFlags.test(mods))<span class="cstat-no" title="statement not covered" >this.raise(start,"Invalid regular expression flag");<span class="cstat-no" title="statement not covered" >i</span></span>f(mods.indexOf('u')&gt;=0&amp;&amp;!regexpUnicodeSupport){<span class="cstat-no" title="statement not covered" >tmp=tmp.replace(/\\u\{([0-9a-fA-F]+)\}/g,<span class="fstat-no" title="function not covered" >function(_match,code,offset){<span class="cstat-no" title="statement not covered" ></span>code=Number("0x"+code);<span class="cstat-no" title="statement not covered" >i</span>f(code&gt;0x10FFFF)<span class="cstat-no" title="statement not covered" >_this.raise(start+offset+3,"Code point out of bounds");<span class="cstat-no" title="statement not covered" >r</span></span>eturn"x";}</span>);<span class="cstat-no" title="statement not covered" >t</span>mp=tmp.replace(/\\u([a-fA-F0-9]{4})|[\uD800-\uDBFF][\uDC00-\uDFFF]/g,"x");}</span>}</span></span>
<span class="cstat-no" title="statement not covered" >var value=null;<span class="cstat-no" title="statement not covered" >i</span>f(!isRhino){<span class="cstat-no" title="statement not covered" >tryCreateRegexp(tmp,undefined,start,this);<span class="cstat-no" title="statement not covered" >v</span>alue=tryCreateRegexp(content,mods);}</span></span>
<span class="cstat-no" title="statement not covered" >return this.finishToken(_tokentype.types.regexp,{pattern:content,flags:mods,value:value});}</span>;pp.readInt=<span class="fstat-no" title="function not covered" >function(radix,len){<span class="cstat-no" title="statement not covered" ></span>var start=this.pos,total=0;<span class="cstat-no" title="statement not covered" >f</span>or(var i=0,e=len==null?Infinity:len;i&lt;e;++i){<span class="cstat-no" title="statement not covered" >var code=this.input.charCodeAt(this.pos),val=undefined;<span class="cstat-no" title="statement not covered" >i</span>f(code&gt;=97)<span class="cstat-no" title="statement not covered" >val=code-97+10;e</span>lse <span class="cstat-no" title="statement not covered" >if(code&gt;=65)<span class="cstat-no" title="statement not covered" >val=code-65+10;e</span>lse <span class="cstat-no" title="statement not covered" >if(code&gt;=48&amp;&amp;code&lt;=57)<span class="cstat-no" title="statement not covered" >val=code-48;e</span>lse <span class="cstat-no" title="statement not covered" >val=Infinity;<span class="cstat-no" title="statement not covered" >i</span></span></span></span>f(val&gt;=radix)<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >+</span></span>+this.pos;<span class="cstat-no" title="statement not covered" >t</span>otal=total*radix+val;}</span></span>
<span class="cstat-no" title="statement not covered" >if(this.pos===start||len!=null&amp;&amp;this.pos-start!==len)<span class="cstat-no" title="statement not covered" >return null;<span class="cstat-no" title="statement not covered" >r</span></span>eturn total;}</span>;pp.readRadixNumber=<span class="fstat-no" title="function not covered" >function(radix){<span class="cstat-no" title="statement not covered" ></span>this.pos+=2;<span class="cstat-no" title="statement not covered" >v</span>ar val=this.readInt(radix);<span class="cstat-no" title="statement not covered" >i</span>f(val==null)<span class="cstat-no" title="statement not covered" >this.raise(this.start+2,"Expected number in radix "+radix);<span class="cstat-no" title="statement not covered" >i</span></span>f(_identifier.isIdentifierStart(this.fullCharCodeAtPos()))<span class="cstat-no" title="statement not covered" >this.raise(this.pos,"Identifier directly after number");<span class="cstat-no" title="statement not covered" >r</span></span>eturn this.finishToken(_tokentype.types.num,val);}</span>;pp.readNumber=<span class="fstat-no" title="function not covered" >function(startsWithDot){<span class="cstat-no" title="statement not covered" ></span>var start=this.pos,isFloat=false,octal=this.input.charCodeAt(this.pos)===48;<span class="cstat-no" title="statement not covered" >i</span>f(!startsWithDot&amp;&amp;this.readInt(10)===null)<span class="cstat-no" title="statement not covered" >this.raise(start,"Invalid number");<span class="cstat-no" title="statement not covered" >v</span></span>ar next=this.input.charCodeAt(this.pos);<span class="cstat-no" title="statement not covered" >i</span>f(next===46){<span class="cstat-no" title="statement not covered" >++this.pos;<span class="cstat-no" title="statement not covered" >t</span>his.readInt(10);<span class="cstat-no" title="statement not covered" >i</span>sFloat=true;<span class="cstat-no" title="statement not covered" >n</span>ext=this.input.charCodeAt(this.pos);}</span></span>
<span class="cstat-no" title="statement not covered" >if(next===69||next===101){<span class="cstat-no" title="statement not covered" >next=this.input.charCodeAt(++this.pos);<span class="cstat-no" title="statement not covered" >i</span>f(next===43||next===45)<span class="cstat-no" title="statement not covered" >++this.pos;<span class="cstat-no" title="statement not covered" >i</span></span>f(this.readInt(10)===null)<span class="cstat-no" title="statement not covered" >this.raise(start,"Invalid number");<span class="cstat-no" title="statement not covered" >i</span></span>sFloat=true;}</span></span>
<span class="cstat-no" title="statement not covered" >if(_identifier.isIdentifierStart(this.fullCharCodeAtPos()))<span class="cstat-no" title="statement not covered" >this.raise(this.pos,"Identifier directly after number");<span class="cstat-no" title="statement not covered" >v</span></span>ar str=this.input.slice(start,this.pos),val=undefined;<span class="cstat-no" title="statement not covered" >i</span>f(isFloat)<span class="cstat-no" title="statement not covered" >val=parseFloat(str);e</span>lse <span class="cstat-no" title="statement not covered" >if(!octal||str.length===1)<span class="cstat-no" title="statement not covered" >val=parseInt(str,10);e</span>lse <span class="cstat-no" title="statement not covered" >if(/[89]/.test(str)||this.strict)<span class="cstat-no" title="statement not covered" >this.raise(start,"Invalid number");e</span>lse <span class="cstat-no" title="statement not covered" >val=parseInt(str,8);<span class="cstat-no" title="statement not covered" >r</span></span></span></span>eturn this.finishToken(_tokentype.types.num,val);}</span>;pp.readCodePoint=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>var ch=this.input.charCodeAt(this.pos),code=undefined;<span class="cstat-no" title="statement not covered" >i</span>f(ch===123){<span class="cstat-no" title="statement not covered" >if(this.options.ecmaVersion&lt;6)<span class="cstat-no" title="statement not covered" >this.unexpected();<span class="cstat-no" title="statement not covered" >v</span></span>ar codePos=++this.pos;<span class="cstat-no" title="statement not covered" >c</span>ode=this.readHexChar(this.input.indexOf('}',this.pos)-this.pos);<span class="cstat-no" title="statement not covered" >+</span>+this.pos;<span class="cstat-no" title="statement not covered" >i</span>f(code&gt;0x10FFFF)<span class="cstat-no" title="statement not covered" >this.raise(codePos,"Code point out of bounds");}</span></span>else{<span class="cstat-no" title="statement not covered" >code=this.readHexChar(4);}</span></span>
<span class="cstat-no" title="statement not covered" >return code;}</span>;<span class="fstat-no" title="function not covered" >function codePointToString(code){<span class="cstat-no" title="statement not covered" ></span>if(code&lt;=0xFFFF)<span class="cstat-no" title="statement not covered" >return String.fromCharCode(code);<span class="cstat-no" title="statement not covered" >c</span></span>ode-=0x10000;<span class="cstat-no" title="statement not covered" >r</span>eturn String.fromCharCode((code&gt;&gt;10)+0xD800,(code&amp;1023)+0xDC00);}</span>
pp.readString=<span class="fstat-no" title="function not covered" >function(quote){<span class="cstat-no" title="statement not covered" ></span>var out="",chunkStart=++this.pos;<span class="cstat-no" title="statement not covered" >f</span>or(;;){<span class="cstat-no" title="statement not covered" >if(this.pos&gt;=this.input.length)<span class="cstat-no" title="statement not covered" >this.raise(this.start,"Unterminated string constant");<span class="cstat-no" title="statement not covered" >v</span></span>ar ch=this.input.charCodeAt(this.pos);<span class="cstat-no" title="statement not covered" >i</span>f(ch===quote)<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >i</span></span>f(ch===92){<span class="cstat-no" title="statement not covered" >out+=this.input.slice(chunkStart,this.pos);<span class="cstat-no" title="statement not covered" >o</span>ut+=this.readEscapedChar(false);<span class="cstat-no" title="statement not covered" >c</span>hunkStart=this.pos;}</span>else{<span class="cstat-no" title="statement not covered" >if(_whitespace.isNewLine(ch))<span class="cstat-no" title="statement not covered" >this.raise(this.start,"Unterminated string constant");<span class="cstat-no" title="statement not covered" >+</span></span>+this.pos;}</span>}</span></span>
<span class="cstat-no" title="statement not covered" >out+=this.input.slice(chunkStart,this.pos++);<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishToken(_tokentype.types.string,out);}</span>;pp.readTmplToken=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>var out="",chunkStart=this.pos;<span class="cstat-no" title="statement not covered" >f</span>or(;;){<span class="cstat-no" title="statement not covered" >if(this.pos&gt;=this.input.length)<span class="cstat-no" title="statement not covered" >this.raise(this.start,"Unterminated template");<span class="cstat-no" title="statement not covered" >v</span></span>ar ch=this.input.charCodeAt(this.pos);<span class="cstat-no" title="statement not covered" >i</span>f(ch===96||ch===36&amp;&amp;this.input.charCodeAt(this.pos+1)===123){<span class="cstat-no" title="statement not covered" >if(this.pos===this.start&amp;&amp;this.type===_tokentype.types.template){<span class="cstat-no" title="statement not covered" >if(ch===36){<span class="cstat-no" title="statement not covered" >this.pos+=2;<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishToken(_tokentype.types.dollarBraceL);}</span>else{<span class="cstat-no" title="statement not covered" >++this.pos;<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishToken(_tokentype.types.backQuote);}</span>}</span></span></span></span>
<span class="cstat-no" title="statement not covered" >out+=this.input.slice(chunkStart,this.pos);<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishToken(_tokentype.types.template,out);}</span>
<span class="cstat-no" title="statement not covered" >if(ch===92){<span class="cstat-no" title="statement not covered" >out+=this.input.slice(chunkStart,this.pos);<span class="cstat-no" title="statement not covered" >o</span>ut+=this.readEscapedChar(true);<span class="cstat-no" title="statement not covered" >c</span>hunkStart=this.pos;}</span>else <span class="cstat-no" title="statement not covered" >if(_whitespace.isNewLine(ch)){<span class="cstat-no" title="statement not covered" >out+=this.input.slice(chunkStart,this.pos);<span class="cstat-no" title="statement not covered" >+</span>+this.pos;<span class="cstat-no" title="statement not covered" >s</span>witch(ch){case 13:<span class="cstat-no" title="statement not covered" >if(this.input.charCodeAt(this.pos)===10)<span class="cstat-no" title="statement not covered" >++this.pos;c</span></span>ase 10:<span class="cstat-no" title="statement not covered" >out+="\n";<span class="cstat-no" title="statement not covered" >b</span>reak;d</span>efault:<span class="cstat-no" title="statement not covered" >out+=String.fromCharCode(ch);<span class="cstat-no" title="statement not covered" >b</span>reak;}</span></span></span></span>
<span class="cstat-no" title="statement not covered" >if(this.options.locations){<span class="cstat-no" title="statement not covered" >++this.curLine;<span class="cstat-no" title="statement not covered" >t</span>his.lineStart=this.pos;}</span></span>
<span class="cstat-no" title="statement not covered" >chunkStart=this.pos;}</span>else{<span class="cstat-no" title="statement not covered" >++this.pos;}</span>}};pp.readEscapedChar=<span class="fstat-no" title="function not covered" >function(inTemplate){<span class="cstat-no" title="statement not covered" ></span>var ch=this.input.charCodeAt(++this.pos);<span class="cstat-no" title="statement not covered" >+</span>+this.pos;<span class="cstat-no" title="statement not covered" >s</span>witch(ch){case 110:<span class="cstat-no" title="statement not covered" >return"\n";c</span>ase 114:<span class="cstat-no" title="statement not covered" >return"\r";c</span>ase 120:<span class="cstat-no" title="statement not covered" >return String.fromCharCode(this.readHexChar(2));c</span>ase 117:<span class="cstat-no" title="statement not covered" >return codePointToString(this.readCodePoint());c</span>ase 116:<span class="cstat-no" title="statement not covered" >return"\t";c</span>ase 98:<span class="cstat-no" title="statement not covered" >return"\b";c</span>ase 118:<span class="cstat-no" title="statement not covered" >return"\u000b";c</span>ase 102:<span class="cstat-no" title="statement not covered" >return"\f";c</span>ase 13:<span class="cstat-no" title="statement not covered" >if(this.input.charCodeAt(this.pos)===10)<span class="cstat-no" title="statement not covered" >++this.pos;c</span></span>ase 10:<span class="cstat-no" title="statement not covered" >if(this.options.locations){<span class="cstat-no" title="statement not covered" >this.lineStart=this.pos;<span class="cstat-no" title="statement not covered" >+</span>+this.curLine;}</span></span></span>
<span class="cstat-no" title="statement not covered" >return"";d</span>efault:<span class="cstat-no" title="statement not covered" >if(ch&gt;=48&amp;&amp;ch&lt;=55){<span class="cstat-no" title="statement not covered" >var octalStr=this.input.substr(this.pos-1,3).match(/^[0-7]+/)[0];<span class="cstat-no" title="statement not covered" >v</span>ar octal=parseInt(octalStr,8);<span class="cstat-no" title="statement not covered" >i</span>f(octal&gt;255){<span class="cstat-no" title="statement not covered" >octalStr=octalStr.slice(0,-1);<span class="cstat-no" title="statement not covered" >o</span>ctal=parseInt(octalStr,8);}</span></span></span>
<span class="cstat-no" title="statement not covered" >if(octal&gt;0&amp;&amp;(this.strict||inTemplate)){<span class="cstat-no" title="statement not covered" >this.raise(this.pos-2,"Octal literal in strict mode");}</span></span>
<span class="cstat-no" title="statement not covered" >this.pos+=octalStr.length-1;<span class="cstat-no" title="statement not covered" >r</span>eturn String.fromCharCode(octal);}</span>
<span class="cstat-no" title="statement not covered" >return String.fromCharCode(ch);}</span>};pp.readHexChar=<span class="fstat-no" title="function not covered" >function(len){<span class="cstat-no" title="statement not covered" ></span>var codePos=this.pos;<span class="cstat-no" title="statement not covered" >v</span>ar n=this.readInt(16,len);<span class="cstat-no" title="statement not covered" >i</span>f(n===null)<span class="cstat-no" title="statement not covered" >this.raise(codePos,"Bad character escape sequence");<span class="cstat-no" title="statement not covered" >r</span></span>eturn n;}</span>;pp.readWord1=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>this.containsEsc=false;<span class="cstat-no" title="statement not covered" >v</span>ar word="",first=true,chunkStart=this.pos;<span class="cstat-no" title="statement not covered" >v</span>ar astral=this.options.ecmaVersion&gt;=6;<span class="cstat-no" title="statement not covered" >w</span>hile(this.pos&lt;this.input.length){<span class="cstat-no" title="statement not covered" >var ch=this.fullCharCodeAtPos();<span class="cstat-no" title="statement not covered" >i</span>f(_identifier.isIdentifierChar(ch,astral)){<span class="cstat-no" title="statement not covered" >this.pos+=ch&lt;=0xffff?1:2;}</span>else <span class="cstat-no" title="statement not covered" >if(ch===92){<span class="cstat-no" title="statement not covered" >this.containsEsc=true;<span class="cstat-no" title="statement not covered" >w</span>ord+=this.input.slice(chunkStart,this.pos);<span class="cstat-no" title="statement not covered" >v</span>ar escStart=this.pos;<span class="cstat-no" title="statement not covered" >i</span>f(this.input.charCodeAt(++this.pos)!=117)</span></span></span></span>
<span class="cstat-no" title="statement not covered" >this.raise(this.pos,"Expecting Unicode escape sequence \\uXXXX");<span class="cstat-no" title="statement not covered" >+</span>+this.pos;<span class="cstat-no" title="statement not covered" >v</span>ar esc=this.readCodePoint();<span class="cstat-no" title="statement not covered" >i</span>f(!(first?_identifier.isIdentifierStart:_identifier.isIdentifierChar)(esc,astral))<span class="cstat-no" title="statement not covered" >this.raise(escStart,"Invalid Unicode escape");<span class="cstat-no" title="statement not covered" >w</span></span>ord+=codePointToString(esc);<span class="cstat-no" title="statement not covered" >c</span>hunkStart=this.pos;}</span>else{<span class="cstat-no" title="statement not covered" >break;}</span>
<span class="cstat-no" title="statement not covered" >first=false;}</span>
<span class="cstat-no" title="statement not covered" >return word+this.input.slice(chunkStart,this.pos);}</span>;pp.readWord=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>var word=this.readWord1();<span class="cstat-no" title="statement not covered" >v</span>ar type=_tokentype.types.name;<span class="cstat-no" title="statement not covered" >i</span>f((this.options.ecmaVersion&gt;=6||!this.containsEsc)&amp;&amp;this.keywords.test(word))<span class="cstat-no" title="statement not covered" >type=_tokentype.keywords[word];<span class="cstat-no" title="statement not covered" >r</span></span>eturn this.finishToken(type,word);}</span>;},{"./identifier":2,"./locutil":5,"./state":10,"./tokentype":14,"./whitespace":16}],14:[function(_dereq_,module,exports){"use strict";exports.__esModule=true;function _classCallCheck(instance,Constructor){<span class="missing-if-branch" title="if path not taken" >I</span>if(!(instance instanceof Constructor)){<span class="cstat-no" title="statement not covered" >throw new TypeError("Cannot call a class as a function");}</span>}
var TokenType=function TokenType(label){var conf=arguments.length&lt;=1||arguments[1]===undefined?{}:arguments[1];_classCallCheck(this,TokenType);this.label=label;this.keyword=conf.keyword;this.beforeExpr=!!conf.beforeExpr;this.startsExpr=!!conf.startsExpr;this.isLoop=!!conf.isLoop;this.isAssign=!!conf.isAssign;this.prefix=!!conf.prefix;this.postfix=!!conf.postfix;this.binop=conf.binop||null;this.updateContext=null;};exports.TokenType=TokenType;function binop(name,prec){return new TokenType(name,{beforeExpr:true,binop:prec});}
var beforeExpr={beforeExpr:true},startsExpr={startsExpr:true};var types={num:new TokenType("num",startsExpr),regexp:new TokenType("regexp",startsExpr),string:new TokenType("string",startsExpr),name:new TokenType("name",startsExpr),eof:new TokenType("eof"),bracketL:new TokenType("[",{beforeExpr:true,startsExpr:true}),bracketR:new TokenType("]"),braceL:new TokenType("{",{beforeExpr:true,startsExpr:true}),braceR:new TokenType("}"),parenL:new TokenType("(",{beforeExpr:true,startsExpr:true}),parenR:new TokenType(")"),comma:new TokenType(",",beforeExpr),semi:new TokenType(";",beforeExpr),colon:new TokenType(":",beforeExpr),dot:new TokenType("."),question:new TokenType("?",beforeExpr),arrow:new TokenType("=&gt;",beforeExpr),template:new TokenType("template"),ellipsis:new TokenType("...",beforeExpr),backQuote:new TokenType("`",startsExpr),dollarBraceL:new TokenType("${",{beforeExpr:true,startsExpr:true}),eq:new TokenType("=",{beforeExpr:true,isAssign:true}),assign:new TokenType("_=",{beforeExpr:true,isAssign:true}),incDec:new TokenType("++/--",{prefix:true,postfix:true,startsExpr:true}),prefix:new TokenType("prefix",{beforeExpr:true,prefix:true,startsExpr:true}),logicalOR:binop("||",1),logicalAND:binop("&amp;&amp;",2),bitwiseOR:binop("|",3),bitwiseXOR:binop("^",4),bitwiseAND:binop("&amp;",5),equality:binop("==/!=",6),relational:binop("&lt;/&gt;",7),bitShift:binop("&lt;&lt;/&gt;&gt;",8),plusMin:new TokenType("+/-",{beforeExpr:true,binop:9,prefix:true,startsExpr:true}),modulo:binop("%",10),star:binop("*",10),slash:binop("/",10)};exports.types=types;var keywords={};exports.keywords=keywords;function kw(name){var options=arguments.length&lt;=1||arguments[1]===undefined?{}:arguments[1];options.keyword=name;keywords[name]=types["_"+name]=new TokenType(name,options);}
kw("break");kw("case",beforeExpr);kw("catch");kw("continue");kw("debugger");kw("default",beforeExpr);kw("do",{isLoop:true,beforeExpr:true});kw("else",beforeExpr);kw("finally");kw("for",{isLoop:true});kw("function",startsExpr);kw("if");kw("return",beforeExpr);kw("switch");kw("throw",beforeExpr);kw("try");kw("var");kw("let");kw("const");kw("while",{isLoop:true});kw("with");kw("new",{beforeExpr:true,startsExpr:true});kw("this",startsExpr);kw("super",startsExpr);kw("class");kw("extends",beforeExpr);kw("export");kw("import");kw("yield",{beforeExpr:true,startsExpr:true});kw("null",startsExpr);kw("true",startsExpr);kw("false",startsExpr);kw("in",{beforeExpr:true,binop:7});kw("instanceof",{beforeExpr:true,binop:7});kw("typeof",{beforeExpr:true,prefix:true,startsExpr:true});kw("void",{beforeExpr:true,prefix:true,startsExpr:true});kw("delete",{beforeExpr:true,prefix:true,startsExpr:true});},{}],15:[function(_dereq_,module,exports){"use strict";exports.__esModule=true;exports.isArray=isArray;exports.has=has;<span class="fstat-no" title="function not covered" >function isArray(obj){<span class="cstat-no" title="statement not covered" ></span>return Object.prototype.toString.call(obj)==="[object Array]";}</span>
<span class="fstat-no" title="function not covered" >function has(obj,propName){<span class="cstat-no" title="statement not covered" ></span>return Object.prototype.hasOwnProperty.call(obj,propName);}</span>},{}],16:[function(_dereq_,module,exports){"use strict";exports.__esModule=true;exports.isNewLine=isNewLine;var lineBreak=/\r\n?|\n|\u2028|\u2029/;exports.lineBreak=lineBreak;var lineBreakG=new RegExp(lineBreak.source,"g");exports.lineBreakG=lineBreakG;<span class="fstat-no" title="function not covered" >function isNewLine(code){<span class="cstat-no" title="statement not covered" ></span>return code===10||code===13||code===0x2028||code==0x2029;}</span>
var nonASCIIwhitespace=/[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/;exports.nonASCIIwhitespace=nonASCIIwhitespace;},{}]},{},[3])(3)});;WebInspector.AcornTokenizer=<span class="fstat-no" title="function not covered" >function(content)</span>
{<span class="cstat-no" title="statement not covered" >this._content=content;<span class="cstat-no" title="statement not covered" >t</span>his._comments=[];<span class="cstat-no" title="statement not covered" >t</span>his._tokenizer=acorn.tokenizer(this._content,{ecmaVersion:6,onComment:this._comments});<span class="cstat-no" title="statement not covered" >t</span>his._lineEndings=this._content.computeLineEndings();<span class="cstat-no" title="statement not covered" >t</span>his._lineNumber=0;<span class="cstat-no" title="statement not covered" >t</span>his._tokenLineStart=0;<span class="cstat-no" title="statement not covered" >t</span>his._tokenLineEnd=0;<span class="cstat-no" title="statement not covered" >t</span>his._nextTokenInternal();}</span>
<span class="cstat-no" title="statement not covered" >WebInspector.AcornTokenizer.punctuator=<span class="fstat-no" title="function not covered" >function(token,values)</span></span>
{<span class="cstat-no" title="statement not covered" >return token.type!==acorn.tokTypes.num&amp;&amp;token.type!==acorn.tokTypes.regexp&amp;&amp;token.type!==acorn.tokTypes.string&amp;&amp;token.type!==acorn.tokTypes.name&amp;&amp;!token.type.keyword&amp;&amp;(!values||(token.type.label.length===1&amp;&amp;values.indexOf(token.type.label)!==-1));}</span>
<span class="cstat-no" title="statement not covered" >WebInspector.AcornTokenizer.keyword=<span class="fstat-no" title="function not covered" >function(token,keyword)</span></span>
{<span class="cstat-no" title="statement not covered" >return!!token.type.keyword&amp;&amp;token.type!==acorn.tokTypes._true&amp;&amp;token.type!==acorn.tokTypes._false&amp;&amp;(!keyword||token.type.keyword===keyword);}</span>
<span class="cstat-no" title="statement not covered" >WebInspector.AcornTokenizer.identifier=<span class="fstat-no" title="function not covered" >function(token,identifier)</span></span>
{<span class="cstat-no" title="statement not covered" >return token.type===acorn.tokTypes.name&amp;&amp;(!identifier||token.value===identifier);}</span>
<span class="cstat-no" title="statement not covered" >WebInspector.AcornTokenizer.lineComment=<span class="fstat-no" title="function not covered" >function(token)</span></span>
{<span class="cstat-no" title="statement not covered" >return token.type==="Line";}</span>
<span class="cstat-no" title="statement not covered" >WebInspector.AcornTokenizer.blockComment=<span class="fstat-no" title="function not covered" >function(token)</span></span>
{<span class="cstat-no" title="statement not covered" >return token.type==="Block";}</span>
<span class="cstat-no" title="statement not covered" >WebInspector.AcornTokenizer.prototype={_nextTokenInternal:<span class="fstat-no" title="function not covered" >function()</span></span>
{<span class="cstat-no" title="statement not covered" >if(this._comments.length)</span>
<span class="cstat-no" title="statement not covered" >return this._comments.shift();<span class="cstat-no" title="statement not covered" >v</span>ar token=this._bufferedToken;<span class="cstat-no" title="statement not covered" >t</span>his._bufferedToken=this._tokenizer.getToken();<span class="cstat-no" title="statement not covered" >r</span>eturn token;}</span>,_rollLineNumberToPosition:<span class="fstat-no" title="function not covered" >function(position)</span>
{<span class="cstat-no" title="statement not covered" >while(this._lineNumber+1&lt;this._lineEndings.length&amp;&amp;position&gt;this._lineEndings[this._lineNumber])</span>
<span class="cstat-no" title="statement not covered" >++this._lineNumber;<span class="cstat-no" title="statement not covered" >r</span>eturn this._lineNumber;}</span>,nextToken:<span class="fstat-no" title="function not covered" >function()</span>
{<span class="cstat-no" title="statement not covered" >var token=this._nextTokenInternal();<span class="cstat-no" title="statement not covered" >i</span>f(token.type===acorn.tokTypes.eof)</span>
<span class="cstat-no" title="statement not covered" >return null;<span class="cstat-no" title="statement not covered" >t</span>his._tokenLineStart=this._rollLineNumberToPosition(token.start);<span class="cstat-no" title="statement not covered" >t</span>his._tokenLineEnd=this._rollLineNumberToPosition(token.end);<span class="cstat-no" title="statement not covered" >t</span>his._tokenColumnStart=this._tokenLineStart&gt;0?token.start-this._lineEndings[this._tokenLineStart-1]-1:token.start;<span class="cstat-no" title="statement not covered" >r</span>eturn token;}</span>,peekToken:<span class="fstat-no" title="function not covered" >function()</span>
{<span class="cstat-no" title="statement not covered" >if(this._comments.length)</span>
<span class="cstat-no" title="statement not covered" >return this._comments[0];<span class="cstat-no" title="statement not covered" >r</span>eturn this._bufferedToken.type!==acorn.tokTypes.eof?this._bufferedToken:null;}</span>,tokenLineStart:<span class="fstat-no" title="function not covered" >function()</span>
{<span class="cstat-no" title="statement not covered" >return this._tokenLineStart;}</span>,tokenLineEnd:<span class="fstat-no" title="function not covered" >function()</span>
{<span class="cstat-no" title="statement not covered" >return this._tokenLineEnd;}</span>,tokenColumnStart:<span class="fstat-no" title="function not covered" >function()</span>
{<span class="cstat-no" title="statement not covered" >return this._tokenColumnStart;}</span>};<span class="cstat-no" title="statement not covered" >WebInspector.ESTreeWalker=<span class="fstat-no" title="function not covered" >function(beforeVisit,afterVisit)</span></span>
{<span class="cstat-no" title="statement not covered" >this._beforeVisit=beforeVisit;<span class="cstat-no" title="statement not covered" >t</span>his._afterVisit=afterVisit||new Function();<span class="cstat-no" title="statement not covered" >t</span>his._walkNulls=false;}</span>
<span class="cstat-no" title="statement not covered" >WebInspector.ESTreeWalker.SkipSubtree={};<span class="cstat-no" title="statement not covered" >W</span>ebInspector.ESTreeWalker.prototype={setWalkNulls:<span class="fstat-no" title="function not covered" >function(value)</span></span>
{<span class="cstat-no" title="statement not covered" >this._walkNulls=value;}</span>,walk:<span class="fstat-no" title="function not covered" >function(ast)</span>
{<span class="cstat-no" title="statement not covered" >this._innerWalk(ast,null);}</span>,_innerWalk:<span class="fstat-no" title="function not covered" >function(node,parent)</span>
{<span class="cstat-no" title="statement not covered" >if(!node&amp;&amp;parent&amp;&amp;this._walkNulls){<span class="cstat-no" title="statement not covered" >node=({type:"Literal",raw:"null",value:null});}</span></span>
<span class="cstat-no" title="statement not covered" >if(!node)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >n</span>ode.parent=parent;<span class="cstat-no" title="statement not covered" >i</span>f(this._beforeVisit.call(null,node)===WebInspector.ESTreeWalker.SkipSubtree){<span class="cstat-no" title="statement not covered" >this._afterVisit.call(null,node);<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span></span>
<span class="cstat-no" title="statement not covered" >var walkOrder=WebInspector.ESTreeWalker._walkOrder[node.type];<span class="cstat-no" title="statement not covered" >i</span>f(!walkOrder){<span class="cstat-no" title="statement not covered" >console.error("Walk order not defined for "+node.type);<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span></span>
<span class="cstat-no" title="statement not covered" >if(node.type==="TemplateLiteral"){<span class="cstat-no" title="statement not covered" >var templateLiteral=(node);<span class="cstat-no" title="statement not covered" >v</span>ar expressionsLength=templateLiteral.expressions.length;<span class="cstat-no" title="statement not covered" >f</span>or(var i=0;i&lt;expressionsLength;++i){<span class="cstat-no" title="statement not covered" >this._innerWalk(templateLiteral.quasis[i],templateLiteral);<span class="cstat-no" title="statement not covered" >t</span>his._innerWalk(templateLiteral.expressions[i],templateLiteral);}</span></span></span>
<span class="cstat-no" title="statement not covered" >this._innerWalk(templateLiteral.quasis[expressionsLength],templateLiteral);}</span>else{<span class="cstat-no" title="statement not covered" >for(var i=0;i&lt;walkOrder.length;++i){<span class="cstat-no" title="statement not covered" >var entity=node[walkOrder[i]];<span class="cstat-no" title="statement not covered" >i</span>f(Array.isArray(entity))</span></span>
<span class="cstat-no" title="statement not covered" >this._walkArray(entity,node);e</span>lse
<span class="cstat-no" title="statement not covered" >this._innerWalk(entity,node);}</span>}
<span class="cstat-no" title="statement not covered" >this._afterVisit.call(null,node);}</span>,_walkArray:<span class="fstat-no" title="function not covered" >function(nodeArray,parentNode)</span>
{<span class="cstat-no" title="statement not covered" >for(var i=0;i&lt;nodeArray.length;++i)</span>
<span class="cstat-no" title="statement not covered" >this._innerWalk(nodeArray[i],parentNode);}</span>,}
<span class="cstat-no" title="statement not covered" >WebInspector.ESTreeWalker._walkOrder={"ArrayExpression":["elements"],"ArrowFunctionExpression":["params","body"],"AssignmentExpression":["left","right"],"BinaryExpression":["left","right"],"BlockStatement":["body"],"BreakStatement":["label"],"CallExpression":["callee","arguments"],"CatchClause":["param","body"],"ClassBody":["body"],"ClassDeclaration":["id","superClass","body"],"ConditionalExpression":["test","consequent","alternate"],"ContinueStatement":["label"],"DebuggerStatement":[],"DoWhileStatement":["body","test"],"EmptyStatement":[],"ExpressionStatement":["expression"],"ForInStatement":["left","right","body"],"ForOfStatement":["left","right","body"],"ForStatement":["init","test","update","body"],"FunctionDeclaration":["id","params","body"],"FunctionExpression":["id","params","body"],"Identifier":[],"IfStatement":["test","consequent","alternate"],"LabeledStatement":["label","body"],"Literal":[],"LogicalExpression":["left","right"],"MemberExpression":["object","property"],"MethodDefinition":["key","value"],"NewExpression":["callee","arguments"],"ObjectExpression":["properties"],"Program":["body"],"Property":["key","value"],"ReturnStatement":["argument"],"SequenceExpression":["expressions"],"Super":[],"SwitchCase":["test","consequent"],"SwitchStatement":["discriminant","cases"],"TaggedTemplateExpression":["tag","quasi"],"TemplateElement":[],"TemplateLiteral":["quasis","expressions"],"ThisExpression":[],"ThrowStatement":["argument"],"TryStatement":["block","handler","finalizer"],"UnaryExpression":["argument"],"UpdateExpression":["argument"],"VariableDeclaration":["declarations"],"VariableDeclarator":["id","init"],"WhileStatement":["test","body"],"WithStatement":["object","body"],"YieldExpression":["argument"]};</span>
&nbsp;</pre></td></tr>
</table></pre>
</div>
<div class="footer">
    <div class="meta">Generated by <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a> at Fri Apr 21 2017 09:11:06 GMT+0000 (UTC)</div>
</div>
</body>
</html>
